{"ast":null,"code":"const Channel = require('./Channel');\n\nconst Role = require('./Role');\n\nconst PermissionOverwrites = require('./PermissionOverwrites');\n\nconst Permissions = require('../util/Permissions');\n\nconst Collection = require('../util/Collection');\n\nconst Constants = require('../util/Constants');\n\nconst Invite = require('./Invite');\n/**\n * Represents a guild channel (i.e. text channels and voice channels).\n * @extends {Channel}\n */\n\n\nclass GuildChannel extends Channel {\n  constructor(guild, data) {\n    super(guild.client, data);\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n\n  setup(data) {\n    super.setup(data);\n    /**\n     * The name of the guild channel\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The position of the channel in the list\n     * @type {number}\n     */\n\n    this.position = data.position;\n    /**\n     * The ID of the category parent of this channel\n     * @type {?Snowflake}\n     */\n\n    this.parentID = data.parent_id;\n    /**\n     * A map of permission overwrites in this channel for roles and users\n     * @type {Collection<Snowflake, PermissionOverwrites>}\n     */\n\n    this.permissionOverwrites = new Collection();\n\n    if (data.permission_overwrites) {\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));\n      }\n    }\n  }\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n\n\n  get calculatedPosition() {\n    const sorted = this.guild._sortedChannels(this.type);\n\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n\n\n  get parent() {\n    return this.guild.channels.get(this.parentID) || null;\n  }\n  /**\n   * Gets the overall set of permissions for a user in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable} member The user that you want to obtain the overall permissions for\n   * @returns {?Permissions}\n   */\n\n\n  memberPermissions(member) {\n    member = this.client.resolver.resolveGuildMember(this.guild, member);\n    if (!member) return null;\n    if (member.id === this.guild.ownerID) return new Permissions(member, Permissions.ALL);\n    const roles = member.roles;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n    const overwrites = this.overwritesFor(member, true, roles);\n    return permissions.remove(overwrites.everyone ? overwrites.everyone.deny : 0).add(overwrites.everyone ? overwrites.everyone.allow : 0).remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : 0).add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : 0).remove(overwrites.member ? overwrites.member.deny : 0).add(overwrites.member ? overwrites.member.allow : 0).freeze();\n  }\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {RoleResolvable} role The role that you want to obtain the overall permissions for\n   * @returns {?Permissions}\n   */\n\n\n  rolePermissions(role) {\n    if (role.permissions & Permissions.FLAGS.ADMINISTRATOR) return new Permissions(Permissions.ALL).freeze();\n    const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.get(role.id);\n    return new Permissions(role.permissions).remove(everyoneOverwrites ? everyoneOverwrites.deny : 0).add(everyoneOverwrites ? everyoneOverwrites.allow : 0).remove(roleOverwrites ? roleOverwrites.deny : 0).add(roleOverwrites ? roleOverwrites.allow : 0).freeze();\n  }\n  /**\n   * Get the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Permissions}\n   */\n\n\n  permissionsFor(memberOrRole) {\n    const member = this.guild.member(memberOrRole);\n    if (member) return this.memberPermissions(member);\n    const role = this.client.resolver.resolveRole(this.guild, memberOrRole);\n    if (role) return this.rolePermissions(role);\n    return null;\n  }\n\n  overwritesFor(member, verified = false, roles = null) {\n    if (!verified) member = this.client.resolver.resolveGuildMember(this.guild, member);\n    if (!member) return [];\n    roles = roles || member.roles;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites\n    };\n  }\n  /**\n   * Replaces the permission overwrites for a channel\n   * @param {Object} [options] Options\n   * @param {ChannelCreationOverwrites[]|Collection<Snowflake, PermissionOverwrites>} [options.overwrites]\n   * Permission overwrites\n   * @param {string} [options.reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * channel.replacePermissionOverwrites({\n   * overwrites: [\n   *   {\n   *      id: message.author.id,\n   *      denied: ['VIEW_CHANNEL'],\n   *   },\n   * ],\n   *   reason: 'Needed to change permissions'\n   * });\n   */\n\n\n  replacePermissionOverwrites({\n    overwrites,\n    reason\n  } = {}) {\n    return this.edit({\n      permissionOverwrites: overwrites,\n      reason\n    }).then(() => this);\n  }\n  /**\n   * An object mapping permission flags to `true` (enabled), `null` (unset) or `false` (disabled).\n   * ```js\n   * {\n   *  'SEND_MESSAGES': true,\n   *  'EMBED_LINKS': null,\n   *  'ATTACH_FILES': false,\n   * }\n   * ```\n   * @typedef {Object} PermissionOverwriteOptions\n   */\n\n  /**\n   * Overwrites the permissions for a user or role in this channel.\n   * @param {Role|Snowflake|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The configuration for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Overwrite permissions for a message author\n   * message.channel.overwritePermissions(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(updated => console.log(updated.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   * @example\n   * // Overwite permissions for a message author and reset some\n   * message.channel.overwritePermissions(message.author, {\n   *   VIEW_CHANNEL: false,\n   *   SEND_MESSAGES: null\n   * })\n   *   .then(updated => console.log(updated.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n\n\n  overwritePermissions(userOrRole, options, reason) {\n    const payload = {\n      allow: 0,\n      deny: 0\n    };\n\n    if (userOrRole instanceof Role) {\n      payload.type = 'role';\n    } else if (this.guild.roles.has(userOrRole)) {\n      userOrRole = this.guild.roles.get(userOrRole);\n      payload.type = 'role';\n    } else {\n      userOrRole = this.client.resolver.resolveUser(userOrRole);\n      payload.type = 'member';\n      if (!userOrRole) return Promise.reject(new TypeError('Supplied parameter was neither a User nor a Role.'));\n    }\n\n    payload.id = userOrRole.id;\n    const prevOverwrite = this.permissionOverwrites.get(userOrRole.id);\n\n    if (prevOverwrite) {\n      payload.allow = prevOverwrite.allow;\n      payload.deny = prevOverwrite.deny;\n    }\n\n    for (const perm in options) {\n      if (options[perm] === true) {\n        payload.allow |= Permissions.FLAGS[perm] || 0;\n        payload.deny &= ~(Permissions.FLAGS[perm] || 0);\n      } else if (options[perm] === false) {\n        payload.allow &= ~(Permissions.FLAGS[perm] || 0);\n        payload.deny |= Permissions.FLAGS[perm] || 0;\n      } else if (options[perm] === null) {\n        payload.allow &= ~(Permissions.FLAGS[perm] || 0);\n        payload.deny &= ~(Permissions.FLAGS[perm] || 0);\n      }\n    }\n\n    return this.client.rest.methods.setChannelOverwrite(this, payload, reason).then(() => this);\n  }\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new TypeError('Could not find a parent to this guild channel.'));\n    const permissionOverwrites = this.parent.permissionOverwrites.map(overwrite => ({\n      deny: overwrite.deny,\n      allow: overwrite.allow,\n      id: overwrite.id,\n      type: overwrite.type\n    }));\n    return this.edit({\n      permissionOverwrites\n    });\n  }\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [type] The type of the channel (Only when creating)\n   * @property {string} [name] The name of the channel\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {CategoryChannel|Snowflake} [parent] The parent or parent ID of the channel\n   * @property {ChannelCreationOverwrites[]|Collection<Snowflake, PermissionOverwrites>} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    return this.client.rest.methods.updateChannel(this, data, reason).then(() => this);\n  }\n  /**\n   * Set a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Set a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {boolean} [relative=false] Move the position relative to its current value\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n\n\n  setPosition(position, relative) {\n    return this.guild.setChannelPosition(this, position, relative);\n  }\n  /**\n   * Set a new parent for the guild channel.\n   * @param {CategoryChannel|SnowFlake} parent The new parent for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's parent\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Sets the parent of a channel\n   * channel.setParent('174674066072928256')\n   *   .then(updated => console.log(`Set the category of ${updated.name} to ${updated.parent.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setParent(parent, reason) {\n    parent = this.client.resolver.resolveChannelID(parent);\n    return this.edit({\n      parent\n    }, reason);\n  }\n  /**\n   * Set a new topic for the guild channel.\n   * @param {string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('Needs more rate limiting')\n   *   .then(updated => console.log(`Channel's new topic is ${updated.topic}`))\n   *   .catch(console.error);\n   */\n\n\n  setTopic(topic, reason) {\n    return this.edit({\n      topic\n    }, reason);\n  }\n  /**\n   * Create an invite to this guild channel.\n   * <warn>This is only available when using a bot account.</warn>\n   * @param {Object} [options={}] Options for the invite\n   * @param {boolean} [options.temporary=false] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @param {number} [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n   * @param {number} [options.maxUses=0] Maximum number of uses\n   * @param {boolean} [options.unique=false] Create a unique invite, or use an existing one with similar settings\n   * @param {string} [reason] Reason for creating the invite\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n\n\n  createInvite(options = {}, reason) {\n    return this.client.rest.methods.createChannelInvite(this, options, reason);\n  }\n  /**\n   * Clone this channel.\n   * @param {string} [name=this.name] Optional name for the new channel, otherwise it has the name of this channel\n   * @param {boolean} [withPermissions=true] Whether to clone the channel with this channel's permission overwrites\n   * @param {boolean} [withTopic=true] Whether to clone the channel with this channel's topic\n   * @param {string} [reason] Reason for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Clone a channel\n   * channel.clone(undefined, true, false, 'Needed a clone')\n   *   .then(clone => console.log(`Cloned ${channel.name} to make a channel called ${clone.name}`))\n   *   .catch(console.error);\n   */\n\n\n  clone(name = this.name, withPermissions = true, withTopic = true, reason) {\n    return this.guild.createChannel(name, {\n      type: this.type,\n      permissionOverwrites: withPermissions ? this.permissionOverwrites : undefined,\n      topic: withTopic ? this.topic : undefined,\n      reason\n    });\n  }\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n\n\n  fetchInvites() {\n    return this.client.rest.makeRequest('get', Constants.Endpoints.Channel(this.id).invites, true).then(data => {\n      const invites = new Collection();\n\n      for (let invite of data) {\n        invite = new Invite(this.client, invite);\n        invites.set(invite.code, invite);\n      }\n\n      return invites;\n    });\n  }\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('Making room for new channels')\n   *   .then(deleted => console.log(`Deleted ${deleted.name} to make room for new channels`))\n   *   .catch(console.error);\n   */\n\n\n  delete(reason) {\n    return this.client.rest.methods.deleteChannel(this, reason);\n  }\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(channel) {\n    let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.equals(channel.permissionOverwrites);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return this.id !== this.guild.id && this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS);\n  }\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has([Permissions.FLAGS.MANAGE_CHANNELS, Permissions.FLAGS.VIEW_CHANNEL]);\n  }\n  /**\n   * Whether the channel is muted\n   * <warn>This is only available when using a user account.</warn>\n   * @type {?boolean}\n   * @readonly\n   * @deprecated\n   */\n\n\n  get muted() {\n    if (this.client.user.bot) return null;\n\n    try {\n      return this.client.user.guildSettings.get(this.guild.id).channelOverrides.get(this.id).muted;\n    } catch (err) {\n      return false;\n    }\n  }\n  /**\n   * The type of message that should notify you\n   * <warn>This is only available when using a user account.</warn>\n   * @type {?MessageNotificationType}\n   * @readonly\n   * @deprecated\n   */\n\n\n  get messageNotifications() {\n    if (this.client.user.bot) return null;\n\n    try {\n      return this.client.user.guildSettings.get(this.guild.id).channelOverrides.get(this.id).messageNotifications;\n    } catch (err) {\n      return Constants.MessageNotificationTypes[3];\n    }\n  }\n  /**\n   * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <#123456789012345678>\n   * console.log(`Hello from ${channel}`);\n   * @example\n   * // Logs: Hello from <#123456789012345678>\n   * console.log('Hello from ' + channel);\n   */\n\n\n  toString() {\n    return \"<#\".concat(this.id, \">\");\n  }\n\n}\n\nmodule.exports = GuildChannel;","map":null,"metadata":{},"sourceType":"script"}