{"ast":null,"code":"const Collector = require('./interfaces/Collector');\n\nconst util = require('util');\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to process\n * @property {number} maxMatches The maximum amount of messages to collect\n */\n\n/**\n * Collects messages on a channel.\n * @extends {Collector}\n */\n\n\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextChannel|DMChannel|GroupDMChannel} channel The channel\n   * @param {CollectorFilter} filter The filter to be applied to this collector\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, filter, options = {}) {\n    super(channel.client, filter, options);\n    /**\n     * The channel\n     * @type {TextBasedChannel}\n     */\n\n    this.channel = channel;\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n\n    this.received = 0;\n    this.client.setMaxListeners(this.client.getMaxListeners() + 1);\n    this.client.on('message', this.listener); // For backwards compatibility (remove in v12)\n\n    if (this.options.max) this.options.maxProcessed = this.options.max;\n    if (this.options.maxMatches) this.options.max = this.options.maxMatches;\n\n    this._reEmitter = message => {\n      /**\n       * Emitted when the collector receives a message.\n       * @event MessageCollector#message\n       * @param {Message} message The message\n       * @deprecated\n       */\n      this.emit('message', message);\n    };\n\n    this.on('collect', this._reEmitter);\n  } // Remove in v12\n\n\n  on(eventName, listener) {\n    if (eventName === 'message') {\n      listener = util.deprecate(listener, 'MessageCollector will soon no longer emit \"message\", use \"collect\" instead');\n    }\n\n    super.on(eventName, listener);\n  }\n  /**\n   * Handle an incoming message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?{key: Snowflake, value: Message}}\n   * @private\n   */\n\n\n  handle(message) {\n    if (message.channel.id !== this.channel.id) return null;\n    this.received++;\n    return {\n      key: message.id,\n      value: message\n    };\n  }\n  /**\n   * Check after collection to see if the collector is done.\n   * @returns {?string} Reason to end the collector, if any\n   * @private\n   */\n\n\n  postCheck() {\n    // Consider changing the end reasons for v12\n    if (this.options.maxMatches && this.collected.size >= this.options.max) return 'matchesLimit';\n    if (this.options.max && this.received >= this.options.maxProcessed) return 'limit';\n    return null;\n  }\n  /**\n   * Removes event listeners.\n   * @private\n   */\n\n\n  cleanup() {\n    this.removeListener('collect', this._reEmitter);\n    this.client.removeListener('message', this.listener);\n    this.client.setMaxListeners(this.client.getMaxListeners() - 1);\n  }\n\n}\n\nmodule.exports = MessageCollector;","map":null,"metadata":{},"sourceType":"script"}