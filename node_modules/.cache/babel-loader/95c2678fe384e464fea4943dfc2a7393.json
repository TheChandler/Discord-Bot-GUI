{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\chand\\\\Desktop\\\\electron-discord\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst browser = typeof window !== 'undefined';\n\nconst querystring = require('querystring');\n\nconst transport = browser ? require('./browser') : require('./node');\n/**\n * Snekfetch\n * @extends Stream.Readable\n * @extends Promise\n */\n\nclass Snekfetch extends transport.Extension {\n  /**\n   * Options to pass to the Snekfetch constructor\n   * @typedef {object} SnekfetchOptions\n   * @memberof Snekfetch\n   * @property {object} [headers] Headers to initialize the request with\n   * @property {object|string|Buffer} [data] Data to initialize the request with\n   * @property {string|Object} [query] Query to intialize the request with\n   * @property {boolean} [followRedirects=true] If the request should follow redirects\n   * @property {object} [qs=querystring] Querystring module to use, any object providing\n   * `stringify` and `parse` for querystrings\n   * @property {number} [version = 1] The http version to use [1 or 2]\n   * @property {external:Agent} [agent] Whether to use an http agent\n   */\n\n  /**\n   * Create a request.\n   * Usually you'll want to do `Snekfetch#method(url [, options])` instead of\n   * `new Snekfetch(method, url [, options])`\n   * @param {string} method HTTP method\n   * @param {string} url URL\n   * @param {SnekfetchOptions} [opts] Options\n   */\n  constructor(method, url, opts = {}) {\n    super();\n    this.options = Object.assign({\n      version: 1,\n      qs: querystring,\n      followRedirects: true\n    }, opts);\n    this.request = transport.buildRequest.call(this, method, url, opts);\n    if (opts.headers) this.set(opts.headers);\n    if (opts.query) this.query(opts.query);\n    if (opts.data) this.send(opts.data);\n  }\n  /**\n   * Add a query param to the request\n   * @param {string|Object} name Name of query param or object to add to query\n   * @param {string} [value] If name is a string value, this will be the value of the query param\n   * @returns {Snekfetch} This request\n   */\n\n\n  query(name, value) {\n    if (!this.request.query) this.request.query = {};\n\n    if (name !== null && typeof name === 'object') {\n      for (const _ref of Object.entries(name)) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const k = _ref2[0];\n        const v = _ref2[1];\n        this.query(k, v);\n      }\n    } else {\n      this.request.query[name] = value;\n    }\n\n    return this;\n  }\n  /**\n   * Add a header to the request\n   * @param {string|Object} name Name of query param or object to add to headers\n   * @param {string} [value] If name is a string value, this will be the value of the header\n   * @returns {Snekfetch} This request\n   */\n\n\n  set(name, value) {\n    if (name !== null && typeof name === 'object') {\n      for (const key of Object.keys(name)) this.set(key, name[key]);\n    } else {\n      this.request.setHeader(name, value);\n    }\n\n    return this;\n  }\n  /**\n   * Attach a form data object\n   * @param {string} name Name of the form attachment\n   * @param {string|Object|Buffer} data Data for the attachment\n   * @param {string} [filename] Optional filename if form attachment name needs to be overridden\n   * @returns {Snekfetch} This request\n   */\n\n\n  attach(...args) {\n    const form = this.data instanceof transport.FormData ? this.data : this.data = new transport.FormData();\n\n    if (typeof args[0] === 'object') {\n      for (const _ref3 of Object.entries(args[0])) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const k = _ref4[0];\n        const v = _ref4[1];\n        this.attach(k, v);\n      }\n    } else {\n      form.append(...args);\n    }\n\n    return this;\n  }\n  /**\n   * Send data with the request\n   * @param {string|Buffer|Object} data Data to send\n   * @returns {Snekfetch} This request\n   */\n\n\n  send(data) {\n    if (data instanceof transport.FormData || transport.shouldSendRaw(data)) {\n      this.data = data;\n    } else if (data !== null && typeof data === 'object') {\n      const header = this.request.getHeader('content-type');\n      let serialize;\n\n      if (header) {\n        if (header.includes('json')) serialize = JSON.stringify;else if (header.includes('urlencoded')) serialize = this.options.qs.stringify;\n      } else {\n        this.set('Content-Type', 'application/json');\n        serialize = JSON.stringify;\n      }\n\n      this.data = serialize(data);\n    } else {\n      this.data = data;\n    }\n\n    return this;\n  }\n\n  then(resolver, rejector) {\n    if (this._response) return this._response.then(resolver, rejector); // eslint-disable-next-line no-return-assign\n\n    return this._response = transport.finalizeRequest.call(this).then(({\n      response,\n      raw,\n      redirect,\n      headers\n    }) => {\n      if (redirect) {\n        let method = this.request.method;\n\n        if ([301, 302].includes(response.statusCode)) {\n          if (method !== 'HEAD') method = 'GET';\n          this.data = null;\n        } else if (response.statusCode === 303) {\n          method = 'GET';\n        }\n\n        const redirectHeaders = this.request.getHeaders();\n        delete redirectHeaders.host;\n        return new Snekfetch(method, redirect, {\n          data: this.data,\n          headers: redirectHeaders,\n          version: this.options.version\n        });\n      }\n\n      const statusCode = response.statusCode || response.status; // forgive me :(\n\n      const self = this; // eslint-disable-line consistent-this\n\n      /**\n       * Response from Snekfetch\n       * @typedef {Object} SnekfetchResponse\n       * @memberof Snekfetch\n       * @prop {HTTP.Request} request\n       * @prop {?string|object|Buffer} body Processed response body\n       * @prop {string} text Raw response body\n       * @prop {boolean} ok If the response code is >= 200 and < 300\n       * @prop {number} status HTTP status code\n       * @prop {string} statusText Human readable HTTP status\n       */\n\n      const res = {\n        request: this.request,\n\n        get body() {\n          delete res.body;\n          const type = this.headers['content-type'];\n\n          if (type && type.includes('application/json')) {\n            try {\n              res.body = JSON.parse(res.text);\n            } catch (err) {\n              res.body = res.text;\n            }\n          } else if (type && type.includes('application/x-www-form-urlencoded')) {\n            res.body = self.options.qs.parse(res.text);\n          } else {\n            res.body = raw;\n          }\n\n          return res.body;\n        },\n\n        text: raw.toString(),\n        ok: statusCode >= 200 && statusCode < 400,\n        headers: headers || response.headers,\n        status: statusCode,\n        statusText: response.statusText || transport.STATUS_CODES[response.statusCode]\n      };\n\n      if (res.ok) {\n        return res;\n      } else {\n        const err = new Error(\"\".concat(res.status, \" \").concat(res.statusText).trim());\n        Object.assign(err, res);\n        return Promise.reject(err);\n      }\n    }).then(resolver, rejector);\n  }\n\n  catch(rejector) {\n    return this.then(null, rejector);\n  }\n  /**\n   * End the request\n   * @param {Function} [cb] Optional callback to handle the response\n   * @returns {Promise} This request\n   */\n\n\n  end(cb) {\n    return this.then(res => cb ? cb(null, res) : res, err => cb ? cb(err, err.status ? err : null) : Promise.reject(err));\n  }\n\n  _finalizeRequest() {\n    if (!this.request) return;\n    if (this.request.method !== 'HEAD') this.set('Accept-Encoding', 'gzip, deflate');\n    if (this.data && this.data.getBoundary) this.set('Content-Type', \"multipart/form-data; boundary=\".concat(this.data.getBoundary()));\n\n    if (this.request.query) {\n      const _this$request$path$sp = this.request.path.split('?'),\n            _this$request$path$sp2 = _slicedToArray(_this$request$path$sp, 2),\n            path = _this$request$path$sp2[0],\n            query = _this$request$path$sp2[1];\n\n      this.request.path = \"\".concat(path, \"?\").concat(this.options.qs.stringify(this.request.query)).concat(query ? \"&\".concat(query) : '');\n    }\n  }\n\n}\n/**\n * Create a ((THIS)) request\n * @dynamic this.METHODS\n * @method Snekfetch.((THIS)lowerCase)\n * @param {string} url The url to request\n * @param {Snekfetch.snekfetchOptions} [opts] Options\n * @returns {Snekfetch}\n */\n\n\nSnekfetch.METHODS = transport.METHODS.concat('BREW').filter(m => m !== 'M-SEARCH');\n\nfor (const method of Snekfetch.METHODS) {\n  Snekfetch[method.toLowerCase()] = function runMethod(url, opts) {\n    const Constructor = this.prototype instanceof Snekfetch ? this : Snekfetch;\n    return new Constructor(method, url, opts);\n  };\n}\n\nmodule.exports = Snekfetch;\n/**\n * @external Agent\n * @see {@link https://nodejs.org/api/http.html#http_class_http_agent}\n */","map":null,"metadata":{},"sourceType":"script"}