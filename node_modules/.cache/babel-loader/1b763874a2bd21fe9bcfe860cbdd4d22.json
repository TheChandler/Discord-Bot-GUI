{"ast":null,"code":"const GuildChannel = require('./GuildChannel');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst Collection = require('../util/Collection');\n/**\n * Represents a guild text channel on Discord.\n * @extends {GuildChannel}\n * @implements {TextBasedChannel}\n */\n\n\nclass TextChannel extends GuildChannel {\n  constructor(guild, data) {\n    super(guild, data);\n    this.type = 'text';\n    /**\n     * A collection containing the messages sent to this channel\n     * @type {Collection<Snowflake, Message>}\n     */\n\n    this.messages = new Collection();\n    this._typing = new Map();\n  }\n\n  setup(data) {\n    super.setup(data);\n    /**\n     * The topic of the text channel\n     * @type {?string}\n     */\n\n    this.topic = data.topic;\n    /**\n     * If the Discord considers this channel NSFW\n     * @type {boolean}\n     * @readonly\n     */\n\n    this.nsfw = Boolean(data.nsfw);\n    /**\n     * The ID of the last message sent in this channel, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = data.last_message_id;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    /**\n     * The ratelimit per user for this channel in seconds\n     * @type {number}\n     */\n\n    this.rateLimitPerUser = data.rate_limit_per_user || 0;\n  }\n  /**\n   * A collection of members that can see this channel, mapped by their ID\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    const members = new Collection();\n\n    for (const member of this.guild.members.values()) {\n      if (this.permissionsFor(member).has('READ_MESSAGES')) {\n        members.set(member.id, member);\n      }\n    }\n\n    return members;\n  }\n  /**\n   * Fetch all webhooks for the channel.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * channel.fetchWebhooks()\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n\n\n  fetchWebhooks() {\n    return this.client.rest.methods.getChannelWebhooks(this);\n  }\n  /**\n   * Sets whether this channel is flagged as NSFW.\n   * @param {boolean} nsfw Whether the channel should be considered NSFW\n   * @param {string} [reason] Reason for changing the channel's NSFW flag\n   * @returns {Promise<TextChannel>}\n   */\n\n\n  setNSFW(nsfw, reason) {\n    return this.edit({\n      nsfw\n    }, reason);\n  }\n  /**\n   * Create a webhook for the channel.\n   * @param {string} name The name of the webhook\n   * @param {BufferResolvable|Base64Resolvable} [avatar] The avatar for the webhook\n   * @param {string} [reason] Reason for creating this webhook\n   * @returns {Promise<Webhook>} webhook The created webhook\n   * @example\n   * channel.createWebhook('Snek', 'https://i.imgur.com/mI8XcpG.jpg')\n   *   .then(webhook => console.log(`Created webhook ${webhook}`))\n   *   .catch(console.error)\n   */\n\n\n  createWebhook(name, avatar, reason) {\n    if (typeof avatar === 'string' && avatar.startsWith('data:')) {\n      return this.client.rest.methods.createWebhook(this, name, avatar, reason);\n    } else {\n      return this.client.resolver.resolveImage(avatar).then(data => this.client.rest.methods.createWebhook(this, name, data, reason));\n    }\n  }\n  /**\n   * Sets the rate limit per user for this channel.\n   * @param {number} rateLimitPerUser The new ratelimit in seconds\n   * @param {string} [reason] Reason for changing the channel's ratelimits\n   * @returns {Promise<TextChannel>}\n   */\n\n\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({\n      rateLimitPerUser\n    }, reason);\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  sendMessage() {}\n\n  sendEmbed() {}\n\n  sendFile() {}\n\n  sendFiles() {}\n\n  sendCode() {}\n\n  fetchMessage() {}\n\n  fetchMessages() {}\n\n  fetchPinnedMessages() {}\n\n  search() {}\n\n  startTyping() {}\n\n  stopTyping() {}\n\n  get typing() {}\n\n  get typingCount() {}\n\n  createCollector() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {}\n\n  bulkDelete() {}\n\n  acknowledge() {}\n\n  _cacheMessage() {}\n\n}\n\nTextBasedChannel.applyToClass(TextChannel, true);\nmodule.exports = TextChannel;","map":null,"metadata":{},"sourceType":"script"}