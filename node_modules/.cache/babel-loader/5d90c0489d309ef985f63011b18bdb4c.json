{"ast":null,"code":"const Action = require('./Action');\n\nconst Constants = require('../../util/Constants');\n\nclass GuildDeleteAction extends Action {\n  constructor(client) {\n    super(client);\n    this.deleted = new Map();\n  }\n\n  handle(data) {\n    const client = this.client;\n    let guild = client.guilds.get(data.id);\n\n    if (guild) {\n      for (const channel of guild.channels.values()) {\n        if (channel.type === 'text') channel.stopTyping(true);\n      }\n\n      if (guild.available && data.unavailable) {\n        // Guild is unavailable\n        guild.available = false;\n        client.emit(Constants.Events.GUILD_UNAVAILABLE, guild); // Stops the GuildDelete packet thinking a guild was actually deleted,\n        // handles emitting of event itself\n\n        return {\n          guild: null\n        };\n      }\n\n      for (const channel of guild.channels.values()) this.client.channels.delete(channel.id);\n\n      if (guild.voiceConnection) guild.voiceConnection.disconnect(); // Delete guild\n\n      client.guilds.delete(guild.id);\n      this.deleted.set(guild.id, guild);\n      this.scheduleForDeletion(guild.id);\n    } else {\n      guild = this.deleted.get(data.id) || null;\n    }\n\n    if (guild) guild.deleted = true;\n    return {\n      guild\n    };\n  }\n\n  scheduleForDeletion(id) {\n    this.client.setTimeout(() => this.deleted.delete(id), this.client.options.restWsBridgeTimeout);\n  }\n\n}\n/**\n * Emitted whenever a guild becomes unavailable, likely due to a server outage.\n * @event Client#guildUnavailable\n * @param {Guild} guild The guild that has become unavailable\n */\n\n\nmodule.exports = GuildDeleteAction;","map":null,"metadata":{},"sourceType":"script"}