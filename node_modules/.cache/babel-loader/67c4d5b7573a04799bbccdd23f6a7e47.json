{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\chand\\\\Desktop\\\\electron-discord\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst util = require('util');\n/**\n * A Map with additional utility methods. This is used throughout discord.js rather than Arrays for anything that has\n * an ID, for significantly improved performance and ease-of-use.\n * @extends {Map}\n */\n\n\nclass Collection extends Map {\n  constructor(iterable) {\n    super(iterable);\n    /**\n     * Cached array for the `array()` method - will be reset to `null` whenever `set()` or `delete()` are called\n     * @name Collection#_array\n     * @type {?Array}\n     * @private\n     */\n\n    Object.defineProperty(this, '_array', {\n      value: null,\n      writable: true,\n      configurable: true\n    });\n    /**\n     * Cached array for the `keyArray()` method - will be reset to `null` whenever `set()` or `delete()` are called\n     * @name Collection#_keyArray\n     * @type {?Array}\n     * @private\n     */\n\n    Object.defineProperty(this, '_keyArray', {\n      value: null,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  set(key, val) {\n    this._array = null;\n    this._keyArray = null;\n    return super.set(key, val);\n  }\n\n  delete(key) {\n    this._array = null;\n    this._keyArray = null;\n    return super.delete(key);\n  }\n  /**\n   * Creates an ordered array of the values of this collection, and caches it internally. The array will only be\n   * reconstructed if an item is added to or removed from the collection, or if you change the length of the array\n   * itself. If you don't want this caching behavior, use `[...collection.values()]` or\n   * `Array.from(collection.values())` instead.\n   * @returns {Array}\n   */\n\n\n  array() {\n    if (!this._array || this._array.length !== this.size) this._array = [...this.values()];\n    return this._array;\n  }\n  /**\n   * Creates an ordered array of the keys of this collection, and caches it internally. The array will only be\n   * reconstructed if an item is added to or removed from the collection, or if you change the length of the array\n   * itself. If you don't want this caching behavior, use `[...collection.keys()]` or\n   * `Array.from(collection.keys())` instead.\n   * @returns {Array}\n   */\n\n\n  keyArray() {\n    if (!this._keyArray || this._keyArray.length !== this.size) this._keyArray = [...this.keys()];\n    return this._keyArray;\n  }\n  /**\n   * Obtains the first value(s) in this collection.\n   * @param {number} [count] Number of values to obtain from the beginning\n   * @returns {*|Array<*>} The single value if `count` is undefined, or an array of values of `count` length\n   */\n\n\n  first(count) {\n    if (count === undefined) return this.values().next().value;\n    if (typeof count !== 'number') throw new TypeError('The count must be a number.');\n    if (!Number.isInteger(count) || count < 1) throw new RangeError('The count must be an integer greater than 0.');\n    count = Math.min(this.size, count);\n    const arr = new Array(count);\n    const iter = this.values();\n\n    for (let i = 0; i < count; i++) arr[i] = iter.next().value;\n\n    return arr;\n  }\n  /**\n   * Obtains the first key(s) in this collection.\n   * @param {number} [count] Number of keys to obtain from the beginning\n   * @returns {*|Array<*>} The single key if `count` is undefined, or an array of keys of `count` length\n   */\n\n\n  firstKey(count) {\n    if (count === undefined) return this.keys().next().value;\n    if (typeof count !== 'number') throw new TypeError('The count must be a number.');\n    if (!Number.isInteger(count) || count < 1) throw new RangeError('The count must be an integer greater than 0.');\n    count = Math.min(this.size, count);\n    const arr = new Array(count);\n    const iter = this.keys();\n\n    for (let i = 0; i < count; i++) arr[i] = iter.next().value;\n\n    return arr;\n  }\n  /**\n   * Obtains the last value(s) in this collection. This relies on {@link Collection#array}, and thus the caching\n   * mechanism applies here as well.\n   * @param {number} [count] Number of values to obtain from the end\n   * @returns {*|Array<*>} The single value if `count` is undefined, or an array of values of `count` length\n   */\n\n\n  last(count) {\n    const arr = this.array();\n    if (count === undefined) return arr[arr.length - 1];\n    if (typeof count !== 'number') throw new TypeError('The count must be a number.');\n    if (!Number.isInteger(count) || count < 1) throw new RangeError('The count must be an integer greater than 0.');\n    return arr.slice(-count);\n  }\n  /**\n   * Obtains the last key(s) in this collection. This relies on {@link Collection#keyArray}, and thus the caching\n   * mechanism applies here as well.\n   * @param {number} [count] Number of keys to obtain from the end\n   * @returns {*|Array<*>} The single key if `count` is undefined, or an array of keys of `count` length\n   */\n\n\n  lastKey(count) {\n    const arr = this.keyArray();\n    if (count === undefined) return arr[arr.length - 1];\n    if (typeof count !== 'number') throw new TypeError('The count must be a number.');\n    if (!Number.isInteger(count) || count < 1) throw new RangeError('The count must be an integer greater than 0.');\n    return arr.slice(-count);\n  }\n  /**\n   * Obtains random value(s) from this collection. This relies on {@link Collection#array}, and thus the caching\n   * mechanism applies here as well.\n   * @param {number} [count] Number of values to obtain randomly\n   * @returns {*|Array<*>} The single value if `count` is undefined, or an array of values of `count` length\n   */\n\n\n  random(count) {\n    let arr = this.array();\n    if (count === undefined) return arr[Math.floor(Math.random() * arr.length)];\n    if (typeof count !== 'number') throw new TypeError('The count must be a number.');\n    if (!Number.isInteger(count) || count < 1) throw new RangeError('The count must be an integer greater than 0.');\n    if (arr.length === 0) return [];\n    const rand = new Array(count);\n    arr = arr.slice();\n\n    for (let i = 0; i < count; i++) rand[i] = arr.splice(Math.floor(Math.random() * arr.length), 1)[0];\n\n    return rand;\n  }\n  /**\n   * Obtains random key(s) from this collection. This relies on {@link Collection#keyArray}, and thus the caching\n   * mechanism applies here as well.\n   * @param {number} [count] Number of keys to obtain randomly\n   * @returns {*|Array<*>} The single key if `count` is undefined, or an array of keys of `count` length\n   */\n\n\n  randomKey(count) {\n    let arr = this.keyArray();\n    if (count === undefined) return arr[Math.floor(Math.random() * arr.length)];\n    if (typeof count !== 'number') throw new TypeError('The count must be a number.');\n    if (!Number.isInteger(count) || count < 1) throw new RangeError('The count must be an integer greater than 0.');\n    if (arr.length === 0) return [];\n    const rand = new Array(count);\n    arr = arr.slice();\n\n    for (let i = 0; i < count; i++) rand[i] = arr.splice(Math.floor(Math.random() * arr.length), 1)[0];\n\n    return rand;\n  }\n  /**\n   * Searches for all items where their specified property's value is identical to the given value\n   * (`item[prop] === value`).\n   * @param {string} prop The property to test against\n   * @param {*} value The expected value\n   * @returns {Array}\n   * @deprecated\n   * @example\n   * collection.findAll('username', 'Bob');\n   */\n\n\n  findAll(prop, value) {\n    if (typeof prop !== 'string') throw new TypeError('Key must be a string.');\n    if (typeof value === 'undefined') throw new Error('Value must be specified.');\n    const results = [];\n\n    for (const item of this.values()) {\n      if (item[prop] === value) results.push(item);\n    }\n\n    return results;\n  }\n  /**\n   * Searches for a single item where its specified property's value is identical to the given value\n   * (`item[prop] === value`), or the given function returns a truthy value. In the latter case, this is identical to\n   * [Array.find()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).\n   * <warn>All collections used in Discord.js are mapped using their `id` property, and if you want to find by id you\n   * should use the `get` method. See\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get) for details.</warn>\n   * @param {string|Function} propOrFn The property to test against, or the function to test with\n   * @param {*} [value] The expected value - only applicable and required if using a property for the first argument\n   * @returns {*}\n   * @example\n   * collection.find('username', 'Bob');\n   * @example\n   * collection.find(val => val.username === 'Bob');\n   */\n\n\n  find(propOrFn, value) {\n    if (typeof propOrFn === 'string') {\n      if (typeof value === 'undefined') throw new Error('Value must be specified.');\n\n      for (const item of this.values()) {\n        if (item[propOrFn] === value) return item;\n      }\n\n      return null;\n    } else if (typeof propOrFn === 'function') {\n      for (const _ref of this) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const key = _ref2[0];\n        const val = _ref2[1];\n        if (propOrFn(val, key, this)) return val;\n      }\n\n      return null;\n    } else {\n      throw new Error('First argument must be a property string or a function.');\n    }\n  }\n  /* eslint-disable max-len */\n\n  /**\n   * Searches for the key of a single item where its specified property's value is identical to the given value\n   * (`item[prop] === value`), or the given function returns a truthy value. In the latter case, this is identical to\n   * [Array.findIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).\n   * @param {string|Function} propOrFn The property to test against, or the function to test with\n   * @param {*} [value] The expected value - only applicable and required if using a property for the first argument\n   * @returns {*}\n   * @example\n   * collection.findKey('username', 'Bob');\n   * @example\n   * collection.findKey(val => val.username === 'Bob');\n   */\n\n\n  findKey(propOrFn, value) {\n    /* eslint-enable max-len */\n    if (typeof propOrFn === 'string') {\n      if (typeof value === 'undefined') throw new Error('Value must be specified.');\n\n      for (const _ref3 of this) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const key = _ref4[0];\n        const val = _ref4[1];\n        if (val[propOrFn] === value) return key;\n      }\n\n      return null;\n    } else if (typeof propOrFn === 'function') {\n      for (const _ref5 of this) {\n        var _ref6 = _slicedToArray(_ref5, 2);\n\n        const key = _ref6[0];\n        const val = _ref6[1];\n        if (propOrFn(val, key, this)) return key;\n      }\n\n      return null;\n    } else {\n      throw new Error('First argument must be a property string or a function.');\n    }\n  }\n  /**\n   * Searches for the existence of a single item where its specified property's value is identical to the given value\n   * (`item[prop] === value`).\n   * <warn>Do not use this to check for an item by its ID. Instead, use `collection.has(id)`. See\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has) for details.</warn>\n   * @param {string} prop The property to test against\n   * @param {*} value The expected value\n   * @returns {boolean}\n   * @deprecated\n   * @example\n   * if (collection.exists('username', 'Bob')) {\n   *  console.log('user here!');\n   * }\n   */\n\n\n  exists(prop, value) {\n    return Boolean(this.find(prop, value));\n  }\n  /**\n   * Removes entries that satisfy the provided filter function.\n   * @param {Function} fn Function used to test (should return a boolean)\n   * @param {Object} [thisArg] Value to use as `this` when executing function\n   * @returns {number} The number of removed entries\n   */\n\n\n  sweep(fn, thisArg) {\n    if (thisArg) fn = fn.bind(thisArg);\n    const previousSize = this.size;\n\n    for (const _ref7 of this) {\n      var _ref8 = _slicedToArray(_ref7, 2);\n\n      const key = _ref8[0];\n      const val = _ref8[1];\n      if (fn(val, key, this)) this.delete(key);\n    }\n\n    return previousSize - this.size;\n  }\n  /**\n   * Identical to\n   * [Array.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n   * but returns a Collection instead of an Array.\n   * @param {Function} fn Function used to test (should return a boolean)\n   * @param {Object} [thisArg] Value to use as `this` when executing function\n   * @returns {Collection}\n   */\n\n\n  filter(fn, thisArg) {\n    if (thisArg) fn = fn.bind(thisArg);\n    const results = new Collection();\n\n    for (const _ref9 of this) {\n      var _ref10 = _slicedToArray(_ref9, 2);\n\n      const key = _ref10[0];\n      const val = _ref10[1];\n      if (fn(val, key, this)) results.set(key, val);\n    }\n\n    return results;\n  }\n  /**\n   * Identical to\n   * [Array.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).\n   * @param {Function} fn Function used to test (should return a boolean)\n   * @param {Object} [thisArg] Value to use as `this` when executing function\n   * @returns {Array}\n   * @deprecated\n   */\n\n\n  filterArray(fn, thisArg) {\n    if (thisArg) fn = fn.bind(thisArg);\n    const results = [];\n\n    for (const _ref11 of this) {\n      var _ref12 = _slicedToArray(_ref11, 2);\n\n      const key = _ref12[0];\n      const val = _ref12[1];\n      if (fn(val, key, this)) results.push(val);\n    }\n\n    return results;\n  }\n  /**\n   * Partitions the collection into two collections where the first collection\n   * contains the items that passed and the second contains the items that failed.\n   * @param {Function} fn Function used to test (should return a boolean)\n   * @param {*} [thisArg] Value to use as `this` when executing function\n   * @returns {Collection[]}\n   * @example const [big, small] = collection.partition(guild => guild.memberCount > 250);\n   */\n\n\n  partition(fn, thisArg) {\n    if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n    const results = [new Collection(), new Collection()];\n\n    for (const _ref13 of this) {\n      var _ref14 = _slicedToArray(_ref13, 2);\n\n      const key = _ref14[0];\n      const val = _ref14[1];\n\n      if (fn(val, key, this)) {\n        results[0].set(key, val);\n      } else {\n        results[1].set(key, val);\n      }\n    }\n\n    return results;\n  }\n  /**\n   * Identical to\n   * [Array.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).\n   * @param {Function} fn Function that produces an element of the new array, taking three arguments\n   * @param {*} [thisArg] Value to use as `this` when executing function\n   * @returns {Array}\n   */\n\n\n  map(fn, thisArg) {\n    if (thisArg) fn = fn.bind(thisArg);\n    const arr = new Array(this.size);\n    let i = 0;\n\n    for (const _ref15 of this) {\n      var _ref16 = _slicedToArray(_ref15, 2);\n\n      const key = _ref16[0];\n      const val = _ref16[1];\n      arr[i++] = fn(val, key, this);\n    }\n\n    return arr;\n  }\n  /**\n   * Identical to\n   * [Array.some()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).\n   * @param {Function} fn Function used to test (should return a boolean)\n   * @param {Object} [thisArg] Value to use as `this` when executing function\n   * @returns {boolean}\n   */\n\n\n  some(fn, thisArg) {\n    if (thisArg) fn = fn.bind(thisArg);\n\n    for (const _ref17 of this) {\n      var _ref18 = _slicedToArray(_ref17, 2);\n\n      const key = _ref18[0];\n      const val = _ref18[1];\n      if (fn(val, key, this)) return true;\n    }\n\n    return false;\n  }\n  /**\n   * Identical to\n   * [Array.every()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every).\n   * @param {Function} fn Function used to test (should return a boolean)\n   * @param {Object} [thisArg] Value to use as `this` when executing function\n   * @returns {boolean}\n   */\n\n\n  every(fn, thisArg) {\n    if (thisArg) fn = fn.bind(thisArg);\n\n    for (const _ref19 of this) {\n      var _ref20 = _slicedToArray(_ref19, 2);\n\n      const key = _ref20[0];\n      const val = _ref20[1];\n      if (!fn(val, key, this)) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Identical to\n   * [Array.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).\n   * @param {Function} fn Function used to reduce, taking four arguments; `accumulator`, `currentValue`, `currentKey`,\n   * and `collection`\n   * @param {*} [initialValue] Starting value for the accumulator\n   * @returns {*}\n   */\n\n\n  reduce(fn, initialValue) {\n    let accumulator;\n\n    if (typeof initialValue !== 'undefined') {\n      accumulator = initialValue;\n\n      for (const _ref21 of this) {\n        var _ref22 = _slicedToArray(_ref21, 2);\n\n        const key = _ref22[0];\n        const val = _ref22[1];\n        accumulator = fn(accumulator, val, key, this);\n      }\n    } else {\n      let first = true;\n\n      for (const _ref23 of this) {\n        var _ref24 = _slicedToArray(_ref23, 2);\n\n        const key = _ref24[0];\n        const val = _ref24[1];\n\n        if (first) {\n          accumulator = val;\n          first = false;\n          continue;\n        }\n\n        accumulator = fn(accumulator, val, key, this);\n      }\n    }\n\n    return accumulator;\n  }\n  /**\n   * Identical to\n   * [Map.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach),\n   * but returns the collection instead of undefined.\n   * @param {Function} fn Function to execute for each element\n   * @param {*} [thisArg] Value to use as `this` when executing function\n   * @returns {Collection}\n   * @example\n   * collection\n   *  .tap(user => console.log(user.username))\n   *  .filter(user => user.bot)\n   *  .tap(user => console.log(user.username));\n   */\n\n\n  tap(fn, thisArg) {\n    this.forEach(fn, thisArg);\n    return this;\n  }\n  /**\n   * Creates an identical shallow copy of this collection.\n   * @returns {Collection}\n   * @example const newColl = someColl.clone();\n   */\n\n\n  clone() {\n    return new this.constructor(this);\n  }\n  /**\n   * Combines this collection with others into a new collection. None of the source collections are modified.\n   * @param {...Collection} collections Collections to merge\n   * @returns {Collection}\n   * @example const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);\n   */\n\n\n  concat(...collections) {\n    const newColl = this.clone();\n\n    for (const coll of collections) {\n      for (const _ref25 of coll) {\n        var _ref26 = _slicedToArray(_ref25, 2);\n\n        const key = _ref26[0];\n        const val = _ref26[1];\n        newColl.set(key, val);\n      }\n    }\n\n    return newColl;\n  }\n  /**\n   * Calls the `delete()` method on all items that have it.\n   * @returns {Promise[]}\n   */\n\n\n  deleteAll() {\n    const returns = [];\n\n    for (const item of this.values()) {\n      if (item.delete) returns.push(item.delete());\n    }\n\n    return returns;\n  }\n  /**\n   * Checks if this collection shares identical key-value pairings with another.\n   * This is different to checking for equality using equal-signs, because\n   * the collections may be different objects, but contain the same data.\n   * @param {Collection} collection Collection to compare with\n   * @returns {boolean} Whether the collections have identical contents\n   */\n\n\n  equals(collection) {\n    if (!collection) return false;\n    if (this === collection) return true;\n    if (this.size !== collection.size) return false;\n    return !this.find((value, key) => {\n      const testVal = collection.get(key);\n      return testVal !== value || testVal === undefined && !collection.has(key);\n    });\n  }\n  /**\n   * The sort() method sorts the elements of a collection in place and returns the collection.\n   * The sort is not necessarily stable. The default sort order is according to string Unicode code points.\n   * @param {Function} [compareFunction] Specifies a function that defines the sort order.\n   * if omitted, the collection is sorted according to each character's Unicode code point value,\n   * according to the string conversion of each element.\n   * @returns {Collection}\n   */\n\n\n  sort(compareFunction = (x, y) => +(x > y) || +(x === y) - 1) {\n    return new Collection([...this.entries()].sort((a, b) => compareFunction(a[1], b[1], a[0], b[0])));\n  }\n\n}\n\nCollection.prototype.findAll = util.deprecate(Collection.prototype.findAll, 'Collection#findAll: use Collection#filter instead');\nCollection.prototype.filterArray = util.deprecate(Collection.prototype.filterArray, 'Collection#filterArray: use Collection#filter instead');\nCollection.prototype.exists = util.deprecate(Collection.prototype.exists, 'Collection#exists: use Collection#some instead');\n\nCollection.prototype.find = function find(propOrFn, value) {\n  if (typeof propOrFn === 'string') {\n    process.emitWarning('Collection#find: pass a function instead', 'DeprecationWarning');\n    if (typeof value === 'undefined') throw new Error('Value must be specified.');\n\n    for (const item of this.values()) {\n      if (item[propOrFn] === value) return item;\n    }\n\n    return null;\n  } else if (typeof propOrFn === 'function') {\n    for (const _ref27 of this) {\n      var _ref28 = _slicedToArray(_ref27, 2);\n\n      const key = _ref28[0];\n      const val = _ref28[1];\n      if (propOrFn(val, key, this)) return val;\n    }\n\n    return null;\n  } else {\n    throw new Error('First argument must be a property string or a function.');\n  }\n};\n\nCollection.prototype.findKey = function findKey(propOrFn, value) {\n  if (typeof propOrFn === 'string') {\n    process.emitWarning('Collection#findKey: pass a function instead', 'DeprecationWarning');\n    if (typeof value === 'undefined') throw new Error('Value must be specified.');\n\n    for (const _ref29 of this) {\n      var _ref30 = _slicedToArray(_ref29, 2);\n\n      const key = _ref30[0];\n      const val = _ref30[1];\n      if (val[propOrFn] === value) return key;\n    }\n\n    return null;\n  } else if (typeof propOrFn === 'function') {\n    for (const _ref31 of this) {\n      var _ref32 = _slicedToArray(_ref31, 2);\n\n      const key = _ref32[0];\n      const val = _ref32[1];\n      if (propOrFn(val, key, this)) return key;\n    }\n\n    return null;\n  } else {\n    throw new Error('First argument must be a property string or a function.');\n  }\n};\n\nmodule.exports = Collection;","map":null,"metadata":{},"sourceType":"script"}