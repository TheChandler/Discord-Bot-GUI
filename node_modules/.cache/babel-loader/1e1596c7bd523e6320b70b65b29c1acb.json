{"ast":null,"code":"const EventEmitter = require('events');\n\nconst path = require('path');\n\nconst Util = require('../util/Util');\n\nconst Attachment = require('./Attachment');\n\nconst RichEmbed = require('./RichEmbed');\n/**\n * Represents a webhook.\n */\n\n\nclass Webhook extends EventEmitter {\n  constructor(client, dataOrID, token) {\n    super();\n\n    if (client) {\n      /**\n       * The client that instantiated the webhook\n       * @name Webhook#client\n       * @type {Client}\n       * @readonly\n       */\n      Object.defineProperty(this, 'client', {\n        value: client\n      });\n      if (dataOrID) this.setup(dataOrID);\n    } else {\n      this.id = dataOrID;\n      this.token = token;\n      Object.defineProperty(this, 'client', {\n        value: this\n      });\n    }\n  }\n\n  setup(data) {\n    /**\n     * The name of the webhook\n     * @type {string}\n     */\n    this.name = data.name;\n    /**\n     * The token for the webhook\n     * @name Webhook#token\n     * @type {string}\n     */\n\n    Object.defineProperty(this, 'token', {\n      value: data.token,\n      writable: true,\n      configurable: true\n    });\n    /**\n     * The avatar for the webhook\n     * @type {?string}\n     */\n\n    this.avatar = data.avatar;\n    /**\n     * The ID of the webhook\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * The guild the webhook belongs to\n     * @type {Snowflake}\n     */\n\n    this.guildID = data.guild_id;\n    /**\n     * The channel the webhook belongs to\n     * @type {Snowflake}\n     */\n\n    this.channelID = data.channel_id;\n\n    if (data.user) {\n      /**\n       * The owner of the webhook\n       * @type {?User|Object}\n       */\n      this.owner = this.client.users ? this.client.users.get(data.user.id) : data.user;\n    } else {\n      this.owner = null;\n    }\n  }\n  /**\n   * Options that can be passed into send, sendMessage, sendFile, sendEmbed, and sendCode.\n   * @typedef {Object} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {Array<RichEmbed|Object>} [embeds] An array of embeds for the message\n   * (see [here](https://discordapp.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {boolean} [disableEveryone=this.client.options.disableEveryone] Whether or not @everyone and @here\n   * should be replaced with plain-text\n   * @property {FileOptions|BufferResolvable|Attachment} [file] A file to send with the message **(deprecated)**\n   * @property {FileOptions[]|BufferResolvable[]|Attachment[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message.\n   */\n\n  /**\n   * Send a message with this webhook.\n   * @param {StringResolvable} content The content to send\n   * @param {WebhookMessageOptions|Attachment|RichEmbed} [options] The options to provide,\n   * can also be just a RichEmbed or Attachment\n   * @returns {Promise<Message|Message[]|Object|Object[]>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send('This is an embed', {\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  send(content, options) {\n    // eslint-disable-line complexity\n    if (!options && typeof content === 'object' && !(content instanceof Array)) {\n      options = content;\n      content = '';\n    } else if (!options) {\n      options = {};\n    }\n\n    if (options instanceof Attachment) options = {\n      files: [options]\n    };\n    if (options instanceof RichEmbed) options = {\n      embeds: [options]\n    };\n\n    if (content) {\n      content = this.client.resolver.resolveString(content);\n      let _options = options,\n          split = _options.split,\n          code = _options.code,\n          disableEveryone = _options.disableEveryone;\n      if (split && typeof split !== 'object') split = {};\n\n      if (typeof code !== 'undefined' && (typeof code !== 'boolean' || code === true)) {\n        content = Util.escapeMarkdown(content, true);\n        content = \"```\".concat(typeof code !== 'boolean' ? code || '' : '', \"\\n\").concat(content, \"\\n```\");\n\n        if (split) {\n          split.prepend = \"```\".concat(typeof code !== 'boolean' ? code || '' : '', \"\\n\");\n          split.append = '\\n```';\n        }\n      }\n\n      if (disableEveryone || typeof disableEveryone === 'undefined' && this.client.options.disableEveryone) {\n        content = content.replace(/@(everyone|here)/g, '@\\u200b$1');\n      }\n\n      if (split) content = Util.splitMessage(content, split);\n    }\n\n    if (options.file) {\n      if (options.files) options.files.push(options.file);else options.files = [options.file];\n    }\n\n    if (options.embeds) {\n      const files = [];\n\n      for (const embed of options.embeds) {\n        if (embed.file) files.push(embed.file);\n      }\n\n      if (options.files) options.files.push(...files);else options.files = files;\n    }\n\n    if (options.embeds) options.embeds = options.embeds.map(e => new RichEmbed(e)._apiTransform());\n\n    if (options.files) {\n      for (let i = 0; i < options.files.length; i++) {\n        let file = options.files[i];\n        if (typeof file === 'string' || Buffer.isBuffer(file)) file = {\n          attachment: file\n        };\n\n        if (!file.name) {\n          if (typeof file.attachment === 'string') {\n            file.name = path.basename(file.attachment);\n          } else if (file.attachment && file.attachment.path) {\n            file.name = path.basename(file.attachment.path);\n          } else if (file instanceof Attachment) {\n            file = {\n              attachment: file.file,\n              name: path.basename(file.file) || 'file.jpg'\n            };\n          } else {\n            file.name = 'file.jpg';\n          }\n        } else if (file instanceof Attachment) {\n          file = file.file;\n        }\n\n        options.files[i] = file;\n      }\n\n      return Promise.all(options.files.map(file => this.client.resolver.resolveFile(file.attachment).then(resource => {\n        file.file = resource;\n        return file;\n      }))).then(files => this.client.rest.methods.sendWebhookMessage(this, content, options, files));\n    }\n\n    return this.client.rest.methods.sendWebhookMessage(this, content, options);\n  }\n  /**\n   * Send a message with this webhook\n   * @param {StringResolvable} content The content to send\n   * @param {WebhookMessageOptions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @deprecated\n   * @example\n   * // Send a message\n   * webhook.sendMessage('hello!')\n   *  .then(message => console.log(`Sent message: ${message.content}`))\n   *  .catch(console.error);\n   */\n\n\n  sendMessage(content, options = {}) {\n    return this.send(content, options);\n  }\n  /**\n   * Send a file with this webhook.\n   * @param {BufferResolvable} attachment The file to send\n   * @param {string} [name='file.jpg'] The name and extension of the file\n   * @param {StringResolvable} [content] Text message to send with the attachment\n   * @param {WebhookMessageOptions} [options] The options to provide\n   * @returns {Promise<Message>}\n   * @deprecated\n   */\n\n\n  sendFile(attachment, name, content, options = {}) {\n    return this.send(content, Object.assign(options, {\n      file: {\n        attachment,\n        name\n      }\n    }));\n  }\n  /**\n   * Send a code block with this webhook.\n   * @param {string} lang Language for the code block\n   * @param {StringResolvable} content Content of the code block\n   * @param {WebhookMessageOptions} options The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @deprecated\n   */\n\n\n  sendCode(lang, content, options = {}) {\n    return this.send(content, Object.assign(options, {\n      code: lang\n    }));\n  }\n  /**\n   * Send a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1000\n   *   }]\n   * }).catch(console.error);\n   */\n\n\n  sendSlackMessage(body) {\n    return this.client.rest.methods.sendSlackWebhookMessage(this, body);\n  }\n  /**\n   * Edit the webhook.\n   * @param {string} name The new name for the webhook\n   * @param {BufferResolvable} [avatar] The new avatar for the webhook\n   * @returns {Promise<Webhook>}\n   */\n\n\n  edit(name = this.name, avatar) {\n    if (avatar) {\n      return this.client.resolver.resolveImage(avatar).then(data => this.client.rest.methods.editWebhook(this, name, data));\n    }\n\n    return this.client.rest.methods.editWebhook(this, name);\n  }\n  /**\n   * Delete the webhook.\n   * @param {string} [reason] Reason for deleting the webhook\n   * @returns {Promise}\n   */\n\n\n  delete(reason) {\n    return this.client.rest.methods.deleteWebhook(this, reason);\n  }\n\n}\n\nmodule.exports = Webhook;","map":null,"metadata":{},"sourceType":"script"}