{"ast":null,"code":"const TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst Role = require('./Role');\n\nconst Permissions = require('../util/Permissions');\n\nconst Collection = require('../util/Collection');\n\nconst _require = require('./Presence'),\n      Presence = _require.Presence;\n\nconst util = require('util');\n/**\n * Represents a member of a guild on Discord.\n * @implements {TextBasedChannel}\n */\n\n\nclass GuildMember {\n  constructor(guild, data) {\n    /**\n     * The client that instantiated this GuildMember\n     * @name GuildMember#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: guild.client\n    });\n    /**\n     * The guild that this member is part of\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The user that this member instance Represents\n     * @type {User}\n     */\n\n    this.user = {};\n    /**\n     * The timestamp this member joined the guild at\n     * @type {number}\n     */\n\n    this.joinedTimestamp = null;\n    this._roles = [];\n    if (data) this.setup(data);\n    /**\n     * The ID of the last message sent by this member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = null;\n    /**\n     * The Message object of the last message sent by this member in their guild, if one was sent\n     * @type {?Message}\n     */\n\n    this.lastMessage = null;\n    /**\n     * Whether the member has been removed from the guild\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n  }\n\n  setup(data) {\n    /**\n     * Whether this member is deafened server-wide\n     * @type {boolean}\n     */\n    this.serverDeaf = data.deaf;\n    /**\n     * Whether this member is muted server-wide\n     * @type {boolean}\n     */\n\n    this.serverMute = data.mute;\n    /**\n     * Whether this member is self-muted\n     * @type {boolean}\n     */\n\n    this.selfMute = data.self_mute;\n    /**\n     * Whether this member is self-deafened\n     * @type {boolean}\n     */\n\n    this.selfDeaf = data.self_deaf;\n    /**\n     * The voice session ID of this member, if any\n     * @type {?Snowflake}\n     */\n\n    this.voiceSessionID = data.session_id;\n    /**\n     * The voice channel ID of this member, if any\n     * @type {?Snowflake}\n     */\n\n    this.voiceChannelID = data.channel_id;\n    /**\n     * Whether this member is speaking and the client is in the same channel\n     * @type {boolean}\n     */\n\n    this.speaking = false;\n    /**\n     * The nickname of this member, if they have one\n     * @type {?string}\n     */\n\n    this.nickname = data.nick || null;\n    if (data.joined_at) this.joinedTimestamp = new Date(data.joined_at).getTime();\n    this.user = data.user;\n    this._roles = data.roles;\n  }\n  /**\n   * The time this member joined the guild\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get joinedAt() {\n    return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;\n  }\n  /**\n   * The presence of this member\n   * @type {Presence}\n   * @readonly\n   */\n\n\n  get presence() {\n    return this.frozenPresence || this.guild.presences.get(this.id) || new Presence(undefined, this.client);\n  }\n  /**\n   * A list of roles that are applied to this member, mapped by the role ID\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n\n\n  get roles() {\n    const list = new Collection();\n    const everyoneRole = this.guild.roles.get(this.guild.id);\n    if (everyoneRole) list.set(everyoneRole.id, everyoneRole);\n\n    for (const roleID of this._roles) {\n      const role = this.guild.roles.get(roleID);\n      if (role) list.set(role.id, role);\n    }\n\n    return list;\n  }\n  /**\n   * The role of this member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get highestRole() {\n    return this.roles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The role of this member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get colorRole() {\n    const coloredRoles = this.roles.filter(role => role.color);\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * The displayed color of this member in base 10\n   * @type {number}\n   * @readonly\n   */\n\n\n  get displayColor() {\n    const role = this.colorRole;\n    return role && role.color || 0;\n  }\n  /**\n   * The displayed color of this member in hexadecimal\n   * @type {string}\n   * @readonly\n   */\n\n\n  get displayHexColor() {\n    const role = this.colorRole;\n    return role && role.hexColor || '#000000';\n  }\n  /**\n   * The role of this member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get hoistRole() {\n    const hoistedRoles = this.roles.filter(role => role.hoist);\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n  /**\n   * Whether this member is muted in any way\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get mute() {\n    return this.selfMute || this.serverMute;\n  }\n  /**\n   * Whether this member is deafened in any way\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deaf() {\n    return this.selfDeaf || this.serverDeaf;\n  }\n  /**\n   * The voice channel this member is in, if any\n   * @type {?VoiceChannel}\n   * @readonly\n   */\n\n\n  get voiceChannel() {\n    return this.guild.channels.get(this.voiceChannelID);\n  }\n  /**\n   * The ID of this user\n   * @type {Snowflake}\n   * @readonly\n   */\n\n\n  get id() {\n    return this.user.id;\n  }\n  /**\n   * The nickname of this member, or their username if they don't have one\n   * @type {string}\n   * @readonly\n   */\n\n\n  get displayName() {\n    return this.nickname || this.user.username;\n  }\n  /**\n   * The overall set of permissions for this member, taking only roles into account\n   * @type {Permissions}\n   * @readonly\n   */\n\n\n  get permissions() {\n    if (this.user.id === this.guild.ownerID) return new Permissions(this, Permissions.ALL);\n    let permissions = 0;\n    const roles = this.roles;\n\n    for (const role of roles.values()) permissions |= role.permissions;\n\n    return new Permissions(this, permissions);\n  }\n  /**\n   * Whether this member is manageable in terms of role hierarchy by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    if (this.user.id === this.guild.ownerID) return false;\n    if (this.user.id === this.client.user.id) return false;\n    return this.guild.me.highestRole.comparePositionTo(this.highestRole) > 0;\n  }\n  /**\n   * Whether this member is kickable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get kickable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.KICK_MEMBERS);\n  }\n  /**\n   * Whether this member is bannable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get bannable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.BAN_MEMBERS);\n  }\n  /**\n   * Returns `channel.permissionsFor(guildMember)`. Returns permissions for this member in a guild channel,\n   * taking into account roles and permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {?Permissions}\n   */\n\n\n  permissionsIn(channel) {\n    channel = this.client.resolver.resolveChannel(channel);\n    if (!channel || !channel.guild) throw new Error('Could not resolve channel to a guild channel.');\n    return channel.permissionsFor(this);\n  }\n  /**\n   * Checks if any of this member's roles have a permission.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {boolean} [explicit=false] Whether to require the role to explicitly have the exact permission\n   * **(deprecated)**\n   * @param {boolean} [checkAdmin] Whether to allow the administrator permission to override\n   * (takes priority over `explicit`)\n   * @param {boolean} [checkOwner] Whether to allow being the guild's owner to override\n   * (takes priority over `explicit`)\n   * @returns {boolean}\n   */\n\n\n  hasPermission(permission, explicit = false, checkAdmin, checkOwner) {\n    if (typeof checkAdmin === 'undefined') checkAdmin = !explicit;\n    if (typeof checkOwner === 'undefined') checkOwner = !explicit;\n    if (checkOwner && this.user.id === this.guild.ownerID) return true;\n    return this.roles.some(r => r.hasPermission(permission, undefined, checkAdmin));\n  }\n  /**\n   * Checks whether the roles of this member allows them to perform specific actions.\n   * @param {PermissionResolvable} permissions The permissions to check for\n   * @param {boolean} [explicit=false] Whether to require the member to explicitly have the exact permissions\n   * @returns {boolean}\n   * @deprecated\n   */\n\n\n  hasPermissions(permissions, explicit = false) {\n    if (!explicit && this.user.id === this.guild.ownerID) return true;\n    return this.hasPermission(permissions, explicit);\n  }\n  /**\n   * Checks whether the roles of this member allows them to perform specific actions, and lists any missing permissions.\n   * @param {PermissionResolvable} permissions The permissions to check for\n   * @param {boolean} [explicit=false] Whether to require the member to explicitly have the exact permissions\n   * @returns {PermissionResolvable}\n   */\n\n\n  missingPermissions(permissions, explicit = false) {\n    if (!(permissions instanceof Array)) permissions = [permissions];\n    return this.permissions.missing(permissions, explicit);\n  }\n  /**\n   * The data for editing this member.\n   * @typedef {Object} GuildMemberEditData\n   * @property {string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role IDs to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {ChannelResolvable|null} [channel] Channel to move member to (if they are connected to voice), or `null`\n   * if you want to kick them from voice\n   */\n\n  /**\n   * Edits this member.\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @param {string} [reason] Reason for editing this user\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set a member's nickname and clear their roles\n   * message.member.edit({\n   *   nick: 'Cool Name',\n   *   roles: []\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    return this.client.rest.methods.updateGuildMember(this, data, reason);\n  }\n  /**\n   * Mute/unmute this member.\n   * @param {boolean} mute Whether or not the member should be muted\n   * @param {string} [reason] Reason for muting or unmuting\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Mute a member with a reason\n   * message.member.setMute(true, 'It needed to be done')\n   *   .then(() => console.log(`Muted ${message.member.displayName}`)))\n   *   .catch(console.error);\n   */\n\n\n  setMute(mute, reason) {\n    return this.edit({\n      mute\n    }, reason);\n  }\n  /**\n   * Deafen/undeafen this member.\n   * @param {boolean} deaf Whether or not the member should be deafened\n   * @param {string} [reason] Reason for deafening or undeafening\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Deafen a member\n   * message.member.setDeaf(true)\n   *   .then(() => console.log(`Deafened ${message.member.displayName}`))\n   *   .catch(console.error);\n   */\n\n\n  setDeaf(deaf, reason) {\n    return this.edit({\n      deaf\n    }, reason);\n  }\n  /**\n   * Moves this member to the given channel.\n   * @param {ChannelResolvable|null} channel Channel to move the member to, or `null` if you want to kick them from\n   * voice\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Moves a member to a voice channel\n   * member.setVoiceChannel('174674066072928256')\n   *   .then(() => console.log(`Moved ${member.displayName}`))\n   *   .catch(console.error);\n   */\n\n\n  setVoiceChannel(channel) {\n    return this.edit({\n      channel\n    });\n  }\n  /**\n   * Sets the roles applied to this member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.setRoles(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all of the member's roles\n   * guildMember.setRoles([])\n   *   .then(member => console.log(`${member.displayName} now has ${member.roles.size} roles`))\n   *   .catch(console.error);\n   */\n\n\n  setRoles(roles, reason) {\n    return this.edit({\n      roles\n    }, reason);\n  }\n  /**\n   * Adds a single role to this member.\n   * @param {RoleResolvable} role The role or ID of the role to add\n   * @param {string} [reason] Reason for adding the role\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Give a role to a member\n   * message.member.addRole('193654001089118208')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  addRole(role, reason) {\n    if (!(role instanceof Role)) role = this.guild.roles.get(role);\n    if (!role) return Promise.reject(new TypeError('Supplied parameter was neither a Role nor a Snowflake.'));\n    return this.client.rest.methods.addMemberRole(this, role, reason);\n  }\n  /**\n   * Adds multiple roles to this member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to add\n   * @param {string} [reason] Reason for adding the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Gives a member a few roles\n   * message.member.addRoles(['193654001089118208', '369308579892690945'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  addRoles(roles, reason) {\n    let allRoles;\n\n    if (roles instanceof Collection) {\n      allRoles = this._roles.slice();\n\n      for (const role of roles.values()) allRoles.push(role.id);\n    } else {\n      allRoles = this._roles.concat(roles);\n    }\n\n    return this.edit({\n      roles: allRoles\n    }, reason);\n  }\n  /**\n   * Removes a single role from this member.\n   * @param {RoleResolvable} role The role or ID of the role to remove\n   * @param {string} [reason] Reason for removing the role\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Remove a role from a member\n   * message.member.removeRole('193654001089118208')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  removeRole(role, reason) {\n    if (!(role instanceof Role)) role = this.guild.roles.get(role);\n    if (!role) return Promise.reject(new TypeError('Supplied parameter was neither a Role nor a Snowflake.'));\n    return this.client.rest.methods.removeMemberRole(this, role, reason);\n  }\n  /**\n   * Removes multiple roles from this member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to remove\n   * @param {string} [reason] Reason for removing the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Removes a few roles from the member\n   * message.member.removeRoles(['193654001089118208', '369308579892690945'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  removeRoles(roles, reason) {\n    const allRoles = this._roles.slice();\n\n    if (roles instanceof Collection) {\n      for (const role of roles.values()) {\n        const index = allRoles.indexOf(role.id);\n        if (index >= 0) allRoles.splice(index, 1);\n      }\n    } else {\n      for (const role of roles) {\n        const index = allRoles.indexOf(role instanceof Role ? role.id : role);\n        if (index >= 0) allRoles.splice(index, 1);\n      }\n    }\n\n    return this.edit({\n      roles: allRoles\n    }, reason);\n  }\n  /**\n   * Set the nickname for this member.\n   * @param {string} nick The nickname for the guild member\n   * @param {string} [reason] Reason for setting the nickname\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Update the member's nickname\n   * message.member.setNickname('Cool Name')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  setNickname(nick, reason) {\n    return this.edit({\n      nick\n    }, reason);\n  }\n  /**\n   * Creates a DM channel between the client and this member.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  createDM() {\n    return this.user.createDM();\n  }\n  /**\n   * Deletes any DMs with this guild member.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  deleteDM() {\n    return this.user.deleteDM();\n  }\n  /**\n   * Kick this member from the guild.\n   * @param {string} [reason] Reason for kicking user\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Kick a member\n   * member.kick()\n   *   .then(() => console.log(`Kicked ${member.displayName}`))\n   *   .catch(console.error);\n   */\n\n\n  kick(reason) {\n    return this.client.rest.methods.kickGuildMember(this.guild, this, reason);\n  }\n  /**\n   * Ban this member.\n   * @param {Object|number|string} [options] Ban options. If a number, the number of days to delete messages for, if a\n   * string, the ban reason. Supplying an object allows you to do both.\n   * @param {number} [options.days=0] Number of days of messages to delete\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Ban a guild member\n   * member.ban(7)\n   *   .then(() => console.log(`Banned ${member.displayName}`))\n   *   .catch(console.error);\n   */\n\n\n  ban(options) {\n    return this.guild.ban(this, options);\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the user's mention instead of the Member object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789>!\n   * console.log(`Hello from ${member}!`);\n   */\n\n\n  toString() {\n    return \"<@\".concat(this.nickname ? '!' : '').concat(this.user.id, \">\");\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  send() {}\n\n  sendMessage() {}\n\n  sendEmbed() {}\n\n  sendFile() {}\n\n  sendCode() {}\n\n}\n\nTextBasedChannel.applyToClass(GuildMember);\nGuildMember.prototype.hasPermissions = util.deprecate(GuildMember.prototype.hasPermissions, 'GuildMember#hasPermissions is deprecated - use GuildMember#hasPermission, it now takes an array');\nGuildMember.prototype.missingPermissions = util.deprecate(GuildMember.prototype.missingPermissions, 'GuildMember#missingPermissions is deprecated - use GuildMember#permissions.missing, it now takes an array');\nmodule.exports = GuildMember;","map":null,"metadata":{},"sourceType":"script"}