{"ast":null,"code":"/**\n * Represents an error from the Discord API.\n * @extends Error\n */\nclass DiscordAPIError extends Error {\n  constructor(path, error, method) {\n    super();\n    const flattened = this.constructor.flattenErrors(error.errors || error).join('\\n');\n    this.name = 'DiscordAPIError';\n    this.message = error.message && flattened ? \"\".concat(error.message, \"\\n\").concat(flattened) : error.message || flattened;\n    /**\n     * The path of the request relative to the HTTP endpoint\n     * @type {string}\n     */\n\n    this.path = path;\n    /**\n     * HTTP error code returned by Discord\n     * @type {number}\n     */\n\n    this.code = error.code;\n    /**\n     * The HTTP method used for the request\n     * @type {string}\n     */\n\n    this.method = method;\n  }\n  /**\n   * Flattens an errors object returned from the API into an array.\n   * @param {Object} obj Discord errors object\n   * @param {string} [key] Used internally to determine key names of nested fields\n   * @returns {string[]}\n   * @private\n   */\n\n\n  static flattenErrors(obj, key = '') {\n    let messages = [];\n\n    for (const k of Object.keys(obj)) {\n      if (k === 'message') continue;\n      const newKey = key ? isNaN(k) ? \"\".concat(key, \".\").concat(k) : \"\".concat(key, \"[\").concat(k, \"]\") : k;\n\n      if (obj[k]._errors) {\n        messages.push(\"\".concat(newKey, \": \").concat(obj[k]._errors.map(e => e.message).join(' ')));\n      } else if (obj[k].code || obj[k].message) {\n        messages.push(\"\".concat(obj[k].code ? \"\".concat(obj[k].code, \": \") : '', \": \").concat(obj[k].message).trim());\n      } else if (typeof obj[k] === 'string') {\n        messages.push(obj[k]);\n      } else {\n        messages = messages.concat(this.flattenErrors(obj[k], newKey));\n      }\n    }\n\n    return messages;\n  }\n\n}\n\nmodule.exports = DiscordAPIError;","map":null,"metadata":{},"sourceType":"script"}