{"ast":null,"code":"const Snowflake = require('../util/Snowflake');\n\nconst Permissions = require('../util/Permissions');\n\nconst util = require('util');\n/**\n * Represents a role on Discord.\n */\n\n\nclass Role {\n  constructor(guild, data) {\n    /**\n     * The client that instantiated the role\n     * @name Role#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: guild.client\n    });\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    if (data) this.setup(data);\n  }\n\n  setup(data) {\n    /**\n     * The ID of the role (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The name of the role\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n\n    this.color = data.color;\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n\n    this.hoist = data.hoist;\n    /**\n     * The position of the role from the API\n     * @type {number}\n     */\n\n    this.position = data.position;\n    /**\n     * The permissions bitfield of the role\n     * @type {number}\n     */\n\n    this.permissions = data.permissions;\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n\n    this.managed = data.managed;\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n\n    this.mentionable = data.mentionable;\n  }\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the role was created\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n\n\n  get hexColor() {\n    let col = this.color.toString(16);\n\n    while (col.length < 6) col = \"0\".concat(col);\n\n    return \"#\".concat(col);\n  }\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    return this.guild.members.filter(m => m.roles.has(this.id));\n  }\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.member(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES_OR_PERMISSIONS)) return false;\n    return clientMember.highestRole.comparePositionTo(this) > 0;\n  }\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n\n\n  get calculatedPosition() {\n    const sorted = this.guild._sortedRoles;\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n  /**\n   * Get an object mapping permission names to whether or not the role enables that permission.\n   * @returns {Object<string, boolean>}\n   * @example\n   * // Print the serialized role permissions\n   * console.log(role.serialize());\n   */\n\n\n  serialize() {\n    return new Permissions(this.permissions).serialize();\n  }\n  /**\n   * Checks if the role has a permission.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {boolean} [explicit=false] Whether to require the role to explicitly have the exact permission\n   * **(deprecated)**\n   * @param {boolean} [checkAdmin] Whether to allow the administrator permission to override\n   * (takes priority over `explicit`)\n   * @returns {boolean}\n   * @example\n   * // See if a role can ban a member\n   * if (role.hasPermission('BAN_MEMBERS')) {\n   *   console.log('This role can ban members');\n   * } else {\n   *   console.log('This role can\\'t ban members');\n   * }\n   */\n\n\n  hasPermission(permission, explicit = false, checkAdmin) {\n    return new Permissions(this.permissions).has(permission, typeof checkAdmin !== 'undefined' ? checkAdmin : !explicit);\n  }\n  /**\n   * Checks if the role has all specified permissions.\n   * @param {PermissionResolvable} permissions The permissions to check for\n   * @param {boolean} [explicit=false] Whether to require the role to explicitly have the exact permissions\n   * @returns {boolean}\n   * @deprecated\n   */\n\n\n  hasPermissions(permissions, explicit = false) {\n    return new Permissions(this.permissions).has(permissions, !explicit);\n  }\n  /**\n   * Compares this role's position to another role's.\n   * @param {Role} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n\n\n  comparePositionTo(role) {\n    return this.constructor.comparePositions(this, role);\n  }\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable|number} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] The reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit name of a role\n   * role.edit({ name: 'New Name' })\n   *   .then(updated => console.log(`Edited role name from ${role.name} to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    return this.client.rest.methods.updateGuildRole(this, data, reason);\n  }\n  /**\n   * Set a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('New Name')\n   *   .then(updated => console.log(`Edited role name from ${role.name} to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Set a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${role.color}`))\n   *   .catch(console.error);\n   */\n\n\n  setColor(color, reason) {\n    return this.edit({\n      color\n    }, reason);\n  }\n  /**\n   * Set whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n\n\n  setHoist(hoist, reason) {\n    return this.edit({\n      hoist\n    }, reason);\n  }\n  /**\n   * Set the position of the role.\n   * @param {number} position The position of the role\n   * @param {boolean} [relative=false] Move the position relative to its current value\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n\n\n  setPosition(position, relative) {\n    return this.guild.setRolePosition(this, position, relative).then(() => this);\n  }\n  /**\n   * Set the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions(['KICK_MEMBERS', 'BAN_MEMBERS'])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n\n\n  setPermissions(permissions, reason) {\n    return this.edit({\n      permissions\n    }, reason);\n  }\n  /**\n   * Set whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true, 'Role needs to be pinged')\n   *   .then(updated => console.log(`Role mentionable: ${updated.mentionable}`))\n   *   .catch(console.error);\n   */\n\n\n  setMentionable(mentionable, reason) {\n    return this.edit({\n      mentionable\n    }, reason);\n  }\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting the role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n\n\n  delete(reason) {\n    return this.client.rest.methods.deleteGuildRole(this, reason);\n  }\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(role) {\n    return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions === role.permissions && this.managed === role.managed;\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the role mention rather than the Role object.\n   * @returns {string}\n   */\n\n\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return \"<@&\".concat(this.id, \">\");\n  }\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n\n\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n\n}\n\nRole.prototype.hasPermissions = util.deprecate(Role.prototype.hasPermissions, 'Role#hasPermissions is deprecated - use Role#hasPermission instead, it now takes an array');\nmodule.exports = Role;","map":null,"metadata":{},"sourceType":"script"}