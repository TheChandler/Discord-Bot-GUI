{"ast":null,"code":"const browser = typeof window !== 'undefined';\n\nconst EventEmitter = require('events');\n\nconst Constants = require('../../util/Constants');\n\nconst zlib = require('zlib');\n\nconst PacketManager = require('./packets/WebSocketPacketManager');\n\nconst erlpack = function findErlpack() {\n  try {\n    const e = require('erlpack');\n\n    if (!e.pack) return null;\n    return e;\n  } catch (e) {\n    return null;\n  }\n}();\n\nconst WebSocket = function findWebSocket() {\n  if (browser) return window.WebSocket; // eslint-disable-line no-undef\n\n  try {\n    return require('@discordjs/uws');\n  } catch (e) {\n    return require('ws');\n  }\n}();\n/**\n * Abstracts a WebSocket connection with decoding/encoding for the Discord gateway.\n * @private\n */\n\n\nclass WebSocketConnection extends EventEmitter {\n  /**\n   * @param {WebSocketManager} manager The WebSocket manager\n   * @param {string} gateway The WebSocket gateway to connect to\n   */\n  constructor(manager, gateway) {\n    super();\n    /**\n     * The WebSocket Manager of this connection\n     * @type {WebSocketManager}\n     */\n\n    this.manager = manager;\n    /**\n     * The client this belongs to\n     * @type {Client}\n     */\n\n    this.client = manager.client;\n    /**\n     * The WebSocket connection itself\n     * @type {WebSocket}\n     */\n\n    this.ws = null;\n    /**\n     * The current sequence of the WebSocket\n     * @type {number}\n     */\n\n    this.sequence = -1;\n    /**\n     * The current status of the client\n     * @type {Status}\n     */\n\n    this.status = Constants.Status.IDLE;\n    /**\n     * The Packet Manager of the connection\n     * @type {WebSocketPacketManager}\n     */\n\n    this.packetManager = new PacketManager(this);\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     */\n\n    this.lastPingTimestamp = 0;\n    /**\n     * Contains the rate limit queue and metadata\n     * @type {Object}\n     */\n\n    this.ratelimit = {\n      queue: [],\n      remaining: 120,\n      total: 120,\n      time: 60e3,\n      resetTimer: null\n    };\n    this.connect(gateway);\n    /**\n     * Events that are disabled (will not be processed)\n     * @type {Object}\n     */\n\n    this.disabledEvents = {};\n    /**\n     * The sequence on WebSocket close\n     * @type {number}\n     */\n\n    this.closeSequence = 0;\n    /**\n     * Whether or not the WebSocket is expecting to be closed\n     * @type {boolean}\n     */\n\n    this.expectingClose = false;\n\n    for (const event of this.client.options.disabledEvents) this.disabledEvents[event] = true;\n  }\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @returns {void}\n   */\n\n\n  triggerReady() {\n    if (this.status === Constants.Status.READY) {\n      this.debug('Tried to mark self as ready, but already ready');\n      return;\n    }\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     */\n\n\n    this.status = Constants.Status.READY;\n    this.client.emit(Constants.Events.READY);\n    this.packetManager.handleQueue();\n  }\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @returns {void}\n   */\n\n\n  checkIfReady() {\n    if (this.status === Constants.Status.READY || this.status === Constants.Status.NEARLY) return false;\n    let unavailableGuilds = 0;\n\n    for (const guild of this.client.guilds.values()) {\n      if (!guild.available) unavailableGuilds++;\n    }\n\n    if (unavailableGuilds === 0) {\n      this.status = Constants.Status.NEARLY;\n      if (!this.client.options.fetchAllMembers) return this.triggerReady(); // Fetch all members before marking self as ready\n\n      const promises = this.client.guilds.map(g => g.fetchMembers());\n      Promise.all(promises).then(() => this.triggerReady()).catch(e => {\n        this.debug(\"Failed to fetch all members before ready! \".concat(e));\n        this.triggerReady();\n      });\n    }\n\n    return true;\n  } // Util\n\n  /**\n   * Emits a debug message.\n   * @param {string} message Debug message\n   * @returns {void}\n   */\n\n\n  debug(message) {\n    if (message instanceof Error) message = message.stack;\n    return this.manager.debug(\"[connection] \".concat(message));\n  }\n  /**\n   * Attempts to serialise data from the WebSocket.\n   * @param {string|Object} data Data to unpack\n   * @returns {Object}\n   */\n\n\n  unpack(data) {\n    if (data instanceof ArrayBuffer) data = Buffer.from(new Uint8Array(data));\n    if (erlpack && typeof data !== 'string') return erlpack.unpack(data);else if (data instanceof Buffer) data = zlib.inflateSync(data).toString();\n    return JSON.parse(data);\n  }\n  /**\n   * Packs an object ready to be sent.\n   * @param {Object} data Data to pack\n   * @returns {string|Buffer}\n   */\n\n\n  pack(data) {\n    return erlpack ? erlpack.pack(data) : JSON.stringify(data);\n  }\n  /**\n   * Processes the current WebSocket queue.\n   */\n\n\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.resetTimer = this.client.setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time);\n    }\n\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n\n      this._send(item);\n\n      this.ratelimit.remaining--;\n    }\n  }\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   */\n\n\n  _send(data) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      this.debug(\"Tried to send packet \".concat(JSON.stringify(data), \" but no WebSocket is available!\"));\n      return;\n    }\n\n    this.ws.send(this.pack(data));\n  }\n  /**\n   * Adds data to the queue to be sent.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   */\n\n\n  send(data) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      this.debug(\"Tried to send packet \".concat(JSON.stringify(data), \" but no WebSocket is available!\"));\n      return;\n    }\n\n    this.ratelimit.queue.push(data);\n    this.processQueue();\n  }\n  /**\n   * Creates a connection to a gateway.\n   * @param {string} gateway The gateway to connect to\n   * @param {number} [after=0] How long to wait before connecting\n   * @param {boolean} [force=false] Whether or not to force a new connection even if one already exists\n   * @returns {boolean}\n   */\n\n\n  connect(gateway = this.gateway, after = 0, force = false) {\n    if (after) return this.client.setTimeout(() => this.connect(gateway, 0, force), after); // eslint-disable-line\n\n    if (this.ws && !force) {\n      this.debug('WebSocket connection already exists');\n      return false;\n    } else if (typeof gateway !== 'string') {\n      this.debug(\"Tried to connect to an invalid gateway: \".concat(gateway));\n      return false;\n    }\n\n    this.expectingClose = false;\n    this.gateway = gateway;\n    this.debug(\"Connecting to \".concat(gateway));\n    const ws = this.ws = new WebSocket(gateway);\n    if (browser) ws.binaryType = 'arraybuffer';\n    ws.onmessage = this.onMessage.bind(this);\n    ws.onopen = this.onOpen.bind(this);\n    ws.onerror = this.onError.bind(this);\n    ws.onclose = this.onClose.bind(this);\n    this.status = Constants.Status.CONNECTING;\n    return true;\n  }\n  /**\n   * Destroys the connection.\n   * @returns {boolean}\n   */\n\n\n  destroy() {\n    const ws = this.ws;\n\n    if (!ws) {\n      this.debug('Attempted to destroy WebSocket but no connection exists!');\n      return false;\n    }\n\n    this.heartbeat(-1);\n    this.expectingClose = true;\n    ws.close(1000);\n    this.packetManager.handleQueue();\n    this.ws = null;\n    this.status = Constants.Status.DISCONNECTED;\n    this.ratelimit.remaining = this.ratelimit.total;\n    return true;\n  }\n  /**\n   * Called whenever a message is received.\n   * @param {Event} event Event received\n   * @returns {boolean}\n   */\n\n\n  onMessage(event) {\n    let data;\n\n    try {\n      data = this.unpack(event.data);\n    } catch (err) {\n      this.emit('debug', err);\n    }\n\n    return this.onPacket(data);\n  }\n  /**\n   * Sets the current sequence of the connection.\n   * @param {number} s New sequence\n   */\n\n\n  setSequence(s) {\n    this.sequence = s > this.sequence ? s : this.sequence;\n  }\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet Received packet\n   * @returns {boolean}\n   */\n\n\n  onPacket(packet) {\n    if (!packet) {\n      this.debug('Received null packet');\n      return false;\n    }\n\n    this.client.emit('raw', packet);\n\n    switch (packet.op) {\n      case Constants.OPCodes.HELLO:\n        return this.heartbeat(packet.d.heartbeat_interval);\n\n      case Constants.OPCodes.RECONNECT:\n        return this.reconnect();\n\n      case Constants.OPCodes.INVALID_SESSION:\n        if (!packet.d) this.sessionID = null;\n        this.sequence = -1;\n        this.debug('Session invalidated -- will identify with a new session');\n        return this.identify(packet.d ? 2500 : 0);\n\n      case Constants.OPCodes.HEARTBEAT_ACK:\n        return this.ackHeartbeat();\n\n      case Constants.OPCodes.HEARTBEAT:\n        return this.heartbeat();\n\n      default:\n        return this.packetManager.handle(packet);\n    }\n  }\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @param {Event} event Received open event\n   */\n\n\n  onOpen(event) {\n    if (event && event.target && event.target.url) this.gateway = event.target.url;\n    this.debug(\"Connected to gateway \".concat(this.gateway));\n    this.identify();\n  }\n  /**\n   * Causes a reconnection to the gateway.\n   */\n\n\n  reconnect() {\n    this.debug('Attemping to reconnect in 5500ms...');\n    /**\n     * Emitted whenever the client tries to reconnect to the WebSocket.\n     * @event Client#reconnecting\n     */\n\n    this.client.emit(Constants.Events.RECONNECTING);\n    this.connect(this.gateway, 5500, true);\n  }\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {Error} error The error that occurred\n   */\n\n\n  onError(error) {\n    if (error && error.message === 'uWs client connection error') {\n      this.reconnect();\n      return;\n    }\n    /**\n     * Emitted whenever the client's WebSocket encounters a connection error.\n     * @event Client#error\n     * @param {Error} error The encountered error\n     */\n\n\n    this.client.emit(Constants.Events.ERROR, error);\n  }\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   */\n\n\n  onClose(event) {\n    this.debug(\"\".concat(this.expectingClose ? 'Client' : 'Server', \" closed the WebSocket connection: \").concat(event.code));\n    this.closeSequence = this.sequence; // Reset the state before trying to fix anything\n\n    this.emit('close', event);\n    this.heartbeat(-1); // Should we reconnect?\n\n    if (event.code === 1000 ? this.expectingClose : Constants.WSCodes[event.code]) {\n      this.expectingClose = false;\n      /**\n       * Emitted when the client's WebSocket disconnects and will no longer attempt to reconnect.\n       * @event Client#disconnect\n       * @param {CloseEvent} event The WebSocket close event\n       */\n\n      this.client.emit(Constants.Events.DISCONNECT, event);\n      this.debug(Constants.WSCodes[event.code]);\n      this.destroy();\n      return;\n    }\n\n    this.expectingClose = false;\n    this.reconnect();\n  } // Heartbeat\n\n  /**\n   * Acknowledges a heartbeat.\n   */\n\n\n  ackHeartbeat() {\n    this.debug(\"Heartbeat acknowledged, latency of \".concat(Date.now() - this.lastPingTimestamp, \"ms\"));\n\n    this.client._pong(this.lastPingTimestamp);\n  }\n  /**\n   * Sends a heartbeat or sets an interval for sending heartbeats.\n   * @param {number} [time] If -1, clears the interval, any other number sets an interval\n   * If no value is given, a heartbeat will be sent instantly\n   */\n\n\n  heartbeat(time) {\n    if (!isNaN(time)) {\n      if (time === -1) {\n        this.debug('Clearing heartbeat interval');\n        this.client.clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      } else {\n        this.debug(\"Setting a heartbeat interval for \".concat(time, \"ms\"));\n        this.heartbeatInterval = this.client.setInterval(() => this.heartbeat(), time);\n      }\n\n      return;\n    }\n\n    this.debug('Sending a heartbeat');\n    this.lastPingTimestamp = Date.now();\n    this.send({\n      op: Constants.OPCodes.HEARTBEAT,\n      d: this.sequence\n    });\n  } // Identification\n\n  /**\n   * Identifies the client on a connection.\n   * @param {number} [after] How long to wait before identifying\n   * @returns {void}\n   */\n\n\n  identify(after) {\n    if (after) return this.client.setTimeout(this.identify.bind(this), after);\n    return this.sessionID ? this.identifyResume() : this.identifyNew();\n  }\n  /**\n   * Identifies as a new connection on the gateway.\n   * @returns {void}\n   */\n\n\n  identifyNew() {\n    if (!this.client.token) {\n      this.debug('No token available to identify a new session with');\n      return;\n    } // Clone the generic payload and assign the token\n\n\n    const d = Object.assign({\n      token: this.client.token\n    }, this.client.options.ws); // Sharding stuff\n\n    const _this$client$options = this.client.options,\n          shardId = _this$client$options.shardId,\n          shardCount = _this$client$options.shardCount;\n    if (shardCount > 0) d.shard = [Number(shardId), Number(shardCount)]; // Send the payload\n\n    this.debug('Identifying as a new session');\n    this.send({\n      op: Constants.OPCodes.IDENTIFY,\n      d\n    });\n  }\n  /**\n   * Resumes a session on the gateway.\n   * @returns {void}\n   */\n\n\n  identifyResume() {\n    if (!this.sessionID) {\n      this.debug('Warning: wanted to resume but session ID not available; identifying as a new session instead');\n      return this.identifyNew();\n    }\n\n    this.debug(\"Attempting to resume session \".concat(this.sessionID));\n    const d = {\n      token: this.client.token,\n      session_id: this.sessionID,\n      seq: this.sequence\n    };\n    return this.send({\n      op: Constants.OPCodes.RESUME,\n      d\n    });\n  }\n\n}\n/**\n * Encoding the WebSocket connections will use.\n * @type {string}\n */\n\n\nWebSocketConnection.ENCODING = erlpack ? 'etf' : 'json';\nWebSocketConnection.WebSocket = WebSocket;\nmodule.exports = WebSocketConnection;","map":null,"metadata":{},"sourceType":"script"}