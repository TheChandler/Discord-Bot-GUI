{"ast":null,"code":"const User = require('./User');\n\nconst Collection = require('../util/Collection');\n\nconst ClientUserSettings = require('./ClientUserSettings');\n\nconst ClientUserGuildSettings = require('./ClientUserGuildSettings');\n\nconst Constants = require('../util/Constants');\n\nconst util = require('util');\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\n\n\nclass ClientUser extends User {\n  setup(data) {\n    super.setup(data);\n    /**\n     * Whether or not this account has been verified\n     * @type {boolean}\n     */\n\n    this.verified = data.verified;\n    /**\n     * The email of this account\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {?string}\n     * @deprecated\n     */\n\n    this.email = data.email;\n    this.localPresence = {};\n    this._typing = new Map();\n    /**\n     * A Collection of friends for the logged in user\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {Collection<Snowflake, User>}\n     * @deprecated\n     */\n\n    this.friends = new Collection();\n    /**\n     * A Collection of blocked users for the logged in user\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {Collection<Snowflake, User>}\n     * @deprecated\n     */\n\n    this.blocked = new Collection();\n    /**\n     * A Collection of notes for the logged in user\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {Collection<Snowflake, string>}\n     * @deprecated\n     */\n\n    this.notes = new Collection();\n    /**\n     * If the user has Discord premium (nitro)\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {?boolean}\n     * @deprecated\n     */\n\n    this.premium = typeof data.premium === 'boolean' ? data.premium : null;\n    /**\n     * If the user has MFA enabled on their account\n     * @type {boolean}\n     */\n\n    this.mfaEnabled = data.mfa_enabled;\n    /**\n     * If the user has ever used a mobile device on Discord\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {?boolean}\n     * @deprecated\n     */\n\n    this.mobile = typeof data.mobile === 'boolean' ? data.mobile : null;\n    /**\n     * Various settings for this user\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {?ClientUserSettings}\n     * @deprecated\n     */\n\n    this.settings = data.user_settings ? new ClientUserSettings(this, data.user_settings) : null;\n    /**\n     * All of the user's guild settings\n     * <warn>This is only filled when using a user account</warn>\n     * @type {Collection<Snowflake, ClientUserGuildSettings>}\n     * @deprecated\n     */\n\n    this.guildSettings = new Collection();\n\n    if (data.user_guild_settings) {\n      for (const settings of data.user_guild_settings) {\n        this.guildSettings.set(settings.guild_id, new ClientUserGuildSettings(settings, this.client));\n      }\n    }\n  }\n\n  edit(data) {\n    return this.client.rest.methods.updateCurrentUser(data);\n  }\n  /**\n   * Set the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @param {string} [password] Current password (only for user accounts)\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n\n\n  setUsername(username, password) {\n    return this.client.rest.methods.updateCurrentUser({\n      username\n    }, password);\n  }\n  /**\n   * Changes the email for the client user's account.\n   * <warn>This is only available when using a user account.</warn>\n   * @param {string} email New email to change to\n   * @param {string} password Current password\n   * @returns {Promise<ClientUser>}\n   * @deprecated\n   * @example\n   * // Set email\n   * client.user.setEmail('bob@gmail.com', 'some amazing password 123')\n   *   .then(user => console.log(`My new email is ${user.email}`))\n   *   .catch(console.error);\n   */\n\n\n  setEmail(email, password) {\n    return this.client.rest.methods.updateCurrentUser({\n      email\n    }, password);\n  }\n  /**\n   * Changes the password for the client user's account.\n   * <warn>This is only available when using a user account.</warn>\n   * @param {string} newPassword New password to change to\n   * @param {string} oldPassword Current password\n   * @returns {Promise<ClientUser>}\n   * @deprecated\n   * @example\n   * // Set password\n   * client.user.setPassword('some new amazing password 456', 'some amazing password 123')\n   *   .then(user => console.log('New password set!'))\n   *   .catch(console.error);\n   */\n\n\n  setPassword(newPassword, oldPassword) {\n    return this.client.rest.methods.updateCurrentUser({\n      password: newPassword\n    }, oldPassword);\n  }\n  /**\n   * Set the avatar of the logged in client.\n   * @param {BufferResolvable|Base64Resolvable} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n\n\n  setAvatar(avatar) {\n    return this.client.resolver.resolveImage(avatar).then(data => this.client.rest.methods.updateCurrentUser({\n      avatar: data\n    }));\n  }\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatus} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {Object} [game] Game the user is playing\n   * @property {string} [game.name] Name of the game\n   * @property {string} [game.url] Twitch stream URL\n   * @property {?ActivityType|number} [game.type] Type of the activity\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ game: { name: 'with discord.js' }, status: 'idle' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  setPresence(data) {\n    // {\"op\":3,\"d\":{\"status\":\"dnd\",\"since\":0,\"game\":null,\"afk\":false}}\n    return new Promise(resolve => {\n      let status = this.localPresence.status || this.presence.status;\n      let game = this.localPresence.game;\n      let afk = this.localPresence.afk || this.presence.afk;\n\n      if (!game && this.presence.game) {\n        game = {\n          name: this.presence.game.name,\n          type: this.presence.game.type,\n          url: this.presence.game.url\n        };\n      }\n\n      if (data.status) {\n        if (typeof data.status !== 'string') throw new TypeError('Status must be a string');\n\n        if (this.bot) {\n          status = data.status;\n        } else {\n          this.settings.update(Constants.UserSettingsMap.status, data.status);\n          status = 'invisible';\n        }\n      }\n\n      if (data.game) {\n        game = data.game;\n        game.type = game.url && typeof game.type === 'undefined' ? 1 : game.type || 0;\n\n        if (typeof game.type === 'string') {\n          game.type = Constants.ActivityTypes.indexOf(game.type.toUpperCase());\n        }\n      } else if (typeof data.game !== 'undefined') {\n        game = null;\n      }\n\n      if (typeof data.afk !== 'undefined') afk = data.afk;\n      afk = Boolean(afk);\n      this.localPresence = {\n        status,\n        game,\n        afk\n      };\n      this.localPresence.since = 0;\n      this.localPresence.game = this.localPresence.game || null;\n      this.client.ws.send({\n        op: 3,\n        d: this.localPresence\n      });\n\n      this.client._setPresence(this.id, this.localPresence);\n\n      resolve(this);\n    });\n  }\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatus\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatus} status Status to change to\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  setStatus(status) {\n    return this.setPresence({\n      status\n    });\n  }\n  /**\n   * Sets the game the client user is playing.\n   * @param {?string} game Game being played\n   * @param {?string} [streamingURL] Twitch stream URL\n   * @returns {Promise<ClientUser>}\n   * @deprecated\n   */\n\n\n  setGame(game, streamingURL) {\n    if (!game) return this.setPresence({\n      game: null\n    });\n    return this.setPresence({\n      game: {\n        name: game,\n        url: streamingURL\n      }\n    });\n  }\n  /**\n   * Sets the activity the client user is playing.\n   * @param {?string} name Activity being played\n   * @param {Object} [options] Options for setting the activity\n   * @param {string} [options.url] Twitch stream URL\n   * @param {ActivityType|number} [options.type] Type of the activity\n   * @returns {Promise<Presence>}\n   * @example\n   * client.user.setActivity('YouTube', { type: 'WATCHING' })\n   *   .then(presence => console.log(`Activity set to ${presence.game ? presence.game.name : 'none'}`))\n   *   .catch(console.error);\n   */\n\n\n  setActivity(name, {\n    url,\n    type\n  } = {}) {\n    if (!name) return this.setPresence({\n      game: null\n    });\n    return this.setPresence({\n      game: {\n        name,\n        type,\n        url\n      }\n    }).then(clientUser => clientUser.presence);\n  }\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} afk Whether or not the user is AFK\n   * @returns {Promise<ClientUser>}\n   */\n\n\n  setAFK(afk) {\n    return this.setPresence({\n      afk\n    });\n  }\n  /**\n   * Fetches messages that mentioned the client's user.\n   * <warn>This is only available when using a user account.</warn>\n   * @param {Object} [options] Options for the fetch\n   * @param {number} [options.limit=25] Maximum number of mentions to retrieve\n   * @param {boolean} [options.roles=true] Whether to include role mentions\n   * @param {boolean} [options.everyone=true] Whether to include everyone/here mentions\n   * @param {GuildResolvable} [options.guild] Limit the search to a specific guild\n   * @returns {Promise<Message[]>}\n   * @deprecated\n   * @example\n   * // Fetch mentions\n   * client.user.fetchMentions()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch mentions from a guild\n   * client.user.fetchMentions({ guild: '222078108977594368' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  fetchMentions(options = {}) {\n    return this.client.rest.methods.fetchMentions(options);\n  }\n  /**\n   * Send a friend request.\n   * <warn>This is only available when using a user account.</warn>\n   * @param {UserResolvable} user The user to send the friend request to\n   * @returns {Promise<User>} The user the friend request was sent to\n   * @deprecated\n   */\n\n\n  addFriend(user) {\n    user = this.client.resolver.resolveUser(user);\n    return this.client.rest.methods.addFriend(user);\n  }\n  /**\n   * Remove a friend.\n   * <warn>This is only available when using a user account.</warn>\n   * @param {UserResolvable} user The user to remove from your friends\n   * @returns {Promise<User>} The user that was removed\n   * @deprecated\n   */\n\n\n  removeFriend(user) {\n    user = this.client.resolver.resolveUser(user);\n    return this.client.rest.methods.removeFriend(user);\n  }\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in less than 10 guilds and user accounts.</warn>\n   * @param {string} name The name of the guild\n   * @param {string} [region] The region for the server\n   * @param {BufferResolvable|Base64Resolvable} [icon=null] The icon for the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n\n\n  createGuild(name, region, icon = null) {\n    if (typeof icon === 'string' && icon.startsWith('data:')) {\n      return this.client.rest.methods.createGuild({\n        name,\n        icon,\n        region\n      });\n    } else {\n      return this.client.resolver.resolveImage(icon).then(data => this.client.rest.methods.createGuild({\n        name,\n        icon: data,\n        region\n      }));\n    }\n  }\n  /**\n   * An object containing either a user or access token, and an optional nickname.\n   * @typedef {Object} GroupDMRecipientOptions\n   * @property {UserResolvable|Snowflake} [user] User to add to the Group DM\n   * (only available if a user is creating the DM)\n   * @property {string} [accessToken] Access token to use to add a user to the Group DM\n   * (only available if a bot is creating the DM)\n   * @property {string} [nick] Permanent nickname (only available if a bot is creating the DM)\n   */\n\n  /**\n   * Creates a Group DM.\n   * @param {GroupDMRecipientOptions[]} recipients The recipients\n   * @returns {Promise<GroupDMChannel>}\n   * @example\n   * // Create a Group DM with a token provided from OAuth\n   * client.user.createGroupDM([{\n   *   user: '66564597481480192',\n   *   accessToken: token\n   * }])\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  createGroupDM(recipients) {\n    return this.client.rest.methods.createGroupDM({\n      recipients: recipients.map(u => this.client.resolver.resolveUserID(u.user)),\n      accessTokens: recipients.map(u => u.accessToken),\n      nicks: recipients.reduce((o, r) => {\n        if (r.nick) o[r.user ? r.user.id : r.id] = r.nick;\n        return o;\n      }, {})\n    });\n  }\n  /**\n   * Accepts an invite to join a guild.\n   * <warn>This is only available when using a user account.</warn>\n   * @param {Invite|string} invite Invite or code to accept\n   * @returns {Promise<Guild>} Joined guild\n   * @deprecated\n   */\n\n\n  acceptInvite(invite) {\n    return this.client.rest.methods.acceptInvite(invite);\n  }\n\n}\n\nClientUser.prototype.acceptInvite = util.deprecate(ClientUser.prototype.acceptInvite, 'ClientUser#acceptInvite: userbot methods will be removed');\nClientUser.prototype.setGame = util.deprecate(ClientUser.prototype.setGame, 'ClientUser#setGame: use ClientUser#setActivity instead');\nClientUser.prototype.addFriend = util.deprecate(ClientUser.prototype.addFriend, 'ClientUser#addFriend: userbot methods will be removed');\nClientUser.prototype.removeFriend = util.deprecate(ClientUser.prototype.removeFriend, 'ClientUser#removeFriend: userbot methods will be removed');\nClientUser.prototype.setPassword = util.deprecate(ClientUser.prototype.setPassword, 'ClientUser#setPassword: userbot methods will be removed');\nClientUser.prototype.setEmail = util.deprecate(ClientUser.prototype.setEmail, 'ClientUser#setEmail: userbot methods will be removed');\nClientUser.prototype.fetchMentions = util.deprecate(ClientUser.prototype.fetchMentions, 'ClientUser#fetchMentions: userbot methods will be removed');\nmodule.exports = ClientUser;","map":null,"metadata":{},"sourceType":"script"}