{"ast":null,"code":"const snekfetch = require('snekfetch');\n\nconst Constants = require('./Constants');\n\nconst ConstantsHttp = Constants.DefaultOptions.http;\n/**\n * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.\n */\n\nclass Util {\n  constructor() {\n    throw new Error(\"The \".concat(this.constructor.name, \" class may not be instantiated.\"));\n  }\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {string} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behaviour of the split\n   * @returns {string|string[]}\n   */\n\n\n  static splitMessage(text, {\n    maxLength = 1950,\n    char = '\\n',\n    prepend = '',\n    append = ''\n  } = {}) {\n    if (text.length <= maxLength) return text;\n    const splitText = text.split(char);\n\n    if (splitText.some(chunk => chunk.length > maxLength)) {\n      throw new Error('Message exceeds the max length and contains no split characters.');\n    }\n\n    const messages = [''];\n    let msg = 0;\n\n    for (let i = 0; i < splitText.length; i++) {\n      if (messages[msg].length + splitText[i].length + 1 > maxLength) {\n        messages[msg] += append;\n        messages.push(prepend);\n        msg++;\n      }\n\n      messages[msg] += (messages[msg].length > 0 && messages[msg] !== prepend ? char : '') + splitText[i];\n    }\n\n    return messages;\n  }\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {boolean} [onlyCodeBlock=false] Whether to only escape codeblocks (takes priority)\n   * @param {boolean} [onlyInlineCode=false] Whether to only escape inline code\n   * @returns {string}\n   */\n\n\n  static escapeMarkdown(text, onlyCodeBlock = false, onlyInlineCode = false) {\n    if (onlyCodeBlock) return text.replace(/```/g, '`\\u200b``');\n    if (onlyInlineCode) return text.replace(/\\\\(`|\\\\)/g, '$1').replace(/(`|\\\\)/g, '\\\\$1');\n    return text.replace(/\\\\(\\*|_|`|~|\\\\)/g, '$1').replace(/(\\*|_|`|~|\\\\)/g, '\\\\$1');\n  }\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {number} [guildsPerShard=1000] Number of guilds per shard\n   * @returns {Promise<number>} The recommended number of shards\n   */\n\n\n  static fetchRecommendedShards(token, guildsPerShard = 1000) {\n    return new Promise((resolve, reject) => {\n      if (!token) throw new Error('A token must be provided.');\n      snekfetch.get(\"\".concat(ConstantsHttp.host, \"/api/v\").concat(ConstantsHttp.version).concat(Constants.Endpoints.gateway.bot)).set('Authorization', \"Bot \".concat(token.replace(/^Bot\\s*/i, ''))).end((err, res) => {\n        if (err) reject(err);\n        resolve(res.body.shards * (1000 / guildsPerShard));\n      });\n    });\n  }\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no ID)\n   * * A URL-encoded UTF-8 emoji (no ID)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {?Object} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n\n\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return {\n      animated: false,\n      name: text,\n      id: null\n    };\n    const m = text.match(/<?(a:)?(\\w{2,32}):(\\d{17,19})>?/);\n    if (!m) return null;\n    return {\n      animated: Boolean(m[1]),\n      name: m[2],\n      id: m[3]\n    };\n  }\n  /**\n   * Checks whether the arrays are equal, also removes duplicated entries from b.\n   * @param {Array<*>} a Array which will not be modified.\n   * @param {Array<*>} b Array to remove duplicated entries from.\n   * @returns {boolean} Whether the arrays are equal.\n   * @private\n   */\n\n\n  static arraysEqual(a, b) {\n    if (a === b) return true;\n    if (a.length !== b.length) return false;\n\n    for (const item of a) {\n      const ind = b.indexOf(item);\n      if (ind !== -1) b.splice(ind, 1);\n    }\n\n    return b.length === 0;\n  }\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n\n\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n\n\n  static mergeDefault(def, given) {\n    if (!given) return def;\n\n    for (const key in def) {\n      if (!{}.hasOwnProperty.call(given, key)) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = this.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n  /**\n   * Converts an ArrayBuffer or string to a Buffer.\n   * @param {ArrayBuffer|string} ab ArrayBuffer to convert\n   * @returns {Buffer}\n   * @private\n   */\n\n\n  static convertToBuffer(ab) {\n    if (typeof ab === 'string') ab = this.str2ab(ab);\n    return Buffer.from(ab);\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param {string} str String to convert\n   * @returns {ArrayBuffer}\n   * @private\n   */\n\n\n  static str2ab(str) {\n    const buffer = new ArrayBuffer(str.length * 2);\n    const view = new Uint16Array(buffer);\n\n    for (var i = 0, strLen = str.length; i < strLen; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  }\n  /**\n   * Makes an Error from a plain info object.\n   * @param {Object} obj Error info\n   * @param {string} obj.name Error type\n   * @param {string} obj.message Message for the error\n   * @param {string} obj.stack Stack for the error\n   * @returns {Error}\n   * @private\n   */\n\n\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {Object}\n   * @private\n   */\n\n\n  static makePlainError(err) {\n    const obj = {};\n    obj.name = err.name;\n    obj.message = err.message;\n    obj.stack = err.stack;\n    return obj;\n  }\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n\n\n  static moveElementInArray(array, element, newIndex, offset = false) {\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n\n    return array.indexOf(element);\n  }\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n}\n\nmodule.exports = Util;","map":null,"metadata":{},"sourceType":"script"}