{"ast":null,"code":"const Channel = require('./Channel');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst Collection = require('../util/Collection');\n\nconst Constants = require('../util/Constants');\n/*\n{ type: 3,\n  recipients:\n   [ { username: 'Charlie',\n       id: '123',\n       discriminator: '6631',\n       avatar: '123' },\n     { username: 'Ben',\n       id: '123',\n       discriminator: '2055',\n       avatar: '123' },\n     { username: 'Adam',\n       id: '123',\n       discriminator: '2406',\n       avatar: '123' } ],\n  owner_id: '123',\n  name: null,\n  last_message_id: '123',\n  id: '123',\n  icon: null }\n*/\n\n/**\n * Represents a Group DM on Discord.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\n\n\nclass GroupDMChannel extends Channel {\n  constructor(client, data) {\n    super(client, data);\n    this.type = 'group';\n    this.messages = new Collection();\n    this._typing = new Map();\n  }\n\n  setup(data) {\n    super.setup(data);\n    /**\n     * The name of this Group DM, can be null if one isn't set\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * A hash of this Group DM icon\n     * @type {?string}\n     */\n\n    this.icon = data.icon;\n    /**\n     * The user ID of this Group DM's owner\n     * @type {string}\n     */\n\n    this.ownerID = data.owner_id;\n    /**\n     * If the DM is managed by an application\n     * @type {boolean}\n     */\n\n    this.managed = data.managed;\n    /**\n     * Application ID of the application that made this Group DM, if applicable\n     * @type {?string}\n     */\n\n    this.applicationID = data.application_id;\n\n    if (data.nicks) {\n      /**\n       * Nicknames for group members\n       * @type {?Collection<Snowflake, string>}\n       */\n      this.nicks = new Collection(data.nicks.map(n => [n.id, n.nick]));\n    }\n\n    if (!this.recipients) {\n      /**\n       * A collection of the recipients of this DM, mapped by their ID\n       * @type {Collection<Snowflake, User>}\n       */\n      this.recipients = new Collection();\n    }\n\n    if (data.recipients) {\n      for (const recipient of data.recipients) {\n        const user = this.client.dataManager.newUser(recipient);\n        this.recipients.set(user.id, user);\n      }\n    }\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n\n\n    this.lastMessageID = data.last_message_id;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n  /**\n   * The owner of this Group DM\n   * @type {User}\n   * @readonly\n   */\n\n\n  get owner() {\n    return this.client.users.get(this.ownerID);\n  }\n  /**\n   * The URL to this guild's icon\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get iconURL() {\n    if (!this.icon) return null;\n    return Constants.Endpoints.Channel(this).Icon(this.client.options.http.cdn, this.icon);\n  }\n\n  edit(data) {\n    const _data = {};\n    if (data.name) _data.name = data.name;\n    if (typeof data.icon !== 'undefined') _data.icon = data.icon;\n    return this.client.rest.methods.updateGroupDMChannel(this, _data);\n  }\n  /**\n   * Whether this channel equals another channel. It compares all properties, so for most operations\n   * it is advisable to just compare `channel.id === channel2.id` as it is much faster and is often\n   * what most users need.\n   * @param {GroupDMChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(channel) {\n    const equal = channel && this.id === channel.id && this.name === channel.name && this.icon === channel.icon && this.ownerID === channel.ownerID;\n\n    if (equal) {\n      return this.recipients.equals(channel.recipients);\n    }\n\n    return equal;\n  }\n  /**\n   * Add a user to the DM\n   * @param {UserResolvable|string} accessTokenOrID Access token or user resolvable\n   * @param {string} [nick] Permanent nickname to give the user (only available if a bot is creating the DM)\n   * @returns {Promise<GroupDMChannel>}\n   */\n\n\n  addUser(accessTokenOrID, nick) {\n    return this.client.rest.methods.addUserToGroupDM(this, {\n      nick,\n      id: this.client.resolver.resolveUserID(accessTokenOrID),\n      accessToken: accessTokenOrID\n    });\n  }\n  /**\n   * Set a new GroupDMChannel icon.\n   * @param {Base64Resolvable|BufferResolvable} icon The new icon of the group dm\n   * @returns {Promise<GroupDMChannel>}\n   * @example\n   * // Edit the group dm icon\n   * channel.setIcon('./icon.png')\n   *  .then(updated => console.log('Updated the channel icon'))\n   *  .catch(console.error);\n   */\n\n\n  setIcon(icon) {\n    return this.client.resolver.resolveImage(icon).then(data => this.edit({\n      icon: data\n    }));\n  }\n  /**\n   * Sets a new name for this Group DM.\n   * @param {string} name New name for this Group DM\n   * @returns {Promise<GroupDMChannel>}\n   */\n\n\n  setName(name) {\n    return this.edit({\n      name\n    });\n  }\n  /**\n   * Removes a user from this Group DM.\n   * @param {UserResolvable} user User to remove\n   * @returns {Promise<GroupDMChannel>}\n   */\n\n\n  removeUser(user) {\n    const id = this.client.resolver.resolveUserID(user);\n    return this.client.rest.methods.removeUserFromGroupDM(this, id);\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the channel's name instead of the Channel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from My Group DM!\n   * console.log(`Hello from ${channel}!`);\n   * @example\n   * // Logs: Hello from My Group DM!\n   * console.log(`Hello from ' + channel + '!');\n   */\n\n\n  toString() {\n    return this.name;\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastPinAt() {}\n\n  send() {}\n\n  sendMessage() {}\n\n  sendEmbed() {}\n\n  sendFile() {}\n\n  sendFiles() {}\n\n  sendCode() {}\n\n  fetchMessage() {}\n\n  fetchMessages() {}\n\n  fetchPinnedMessages() {}\n\n  search() {}\n\n  startTyping() {}\n\n  stopTyping() {}\n\n  get typing() {}\n\n  get typingCount() {}\n\n  createCollector() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {} // Doesn't work on Group DMs; bulkDelete() {}\n\n\n  acknowledge() {}\n\n  _cacheMessage() {}\n\n}\n\nTextBasedChannel.applyToClass(GroupDMChannel, true, ['bulkDelete']);\nmodule.exports = GroupDMChannel;","map":null,"metadata":{},"sourceType":"script"}