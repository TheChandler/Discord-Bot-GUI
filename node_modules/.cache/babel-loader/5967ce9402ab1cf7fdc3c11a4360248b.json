{"ast":null,"code":"const RequestHandler = require('./RequestHandler');\n\nconst DiscordAPIError = require('../DiscordAPIError');\n\nconst _require = require('../../../util/Constants'),\n      RATE_LIMIT = _require.Events.RATE_LIMIT;\n/**\n * Handles API Requests sequentially, i.e. we wait until the current request is finished before moving onto\n * the next. This plays a _lot_ nicer in terms of avoiding 429's when there is more than one session of the account,\n * but it can be slower.\n * @extends {RequestHandler}\n * @private\n */\n\n\nclass SequentialRequestHandler extends RequestHandler {\n  /**\n   * @param {RESTManager} restManager The REST manager to use\n   * @param {string} endpoint The endpoint to handle\n   */\n  constructor(restManager, endpoint) {\n    super(restManager, endpoint);\n    /**\n     * The client that instantiated this handler\n     * @type {Client}\n     */\n\n    this.client = restManager.client;\n    /**\n     * The endpoint that this handler is handling\n     * @type {string}\n     */\n\n    this.endpoint = endpoint;\n    /**\n     * The time difference between Discord's Dates and the local computer's Dates. A positive number means the local\n     * computer's time is ahead of Discord's\n     * @type {number}\n     */\n\n    this.timeDifference = 0;\n    /**\n     * Whether the queue is being processed or not\n     * @type {boolean}\n     */\n\n    this.busy = false;\n  }\n\n  push(request) {\n    super.push(request);\n    this.handle();\n  }\n  /**\n   * Performs a request then resolves a promise to indicate its readiness for a new request.\n   * @param {APIRequest} item The item to execute\n   * @returns {Promise<?Object|Error>}\n   */\n\n\n  execute(item) {\n    this.busy = true;\n    return new Promise(resolve => {\n      item.request.gen().end((err, res) => {\n        if (res && res.headers) {\n          this.requestLimit = Number(res.headers['x-ratelimit-limit']);\n          this.requestResetTime = Number(res.headers['x-ratelimit-reset']) * 1000;\n          this.requestRemaining = Number(res.headers['x-ratelimit-remaining']);\n          this.timeDifference = Date.now() - new Date(res.headers.date).getTime();\n        }\n\n        if (err) {\n          if (err.status === 429) {\n            this.queue.unshift(item);\n            this.client.setTimeout(() => {\n              this.globalLimit = false;\n              resolve();\n            }, Number(res.headers['retry-after']) + this.client.options.restTimeOffset);\n            if (res.headers['x-ratelimit-global']) this.globalLimit = true;\n          } else if (err.status >= 500 && err.status < 600) {\n            if (item.retries === this.client.options.retryLimit) {\n              item.reject(err);\n              resolve();\n            } else {\n              item.retries++;\n              this.queue.unshift(item);\n              this.client.setTimeout(resolve, 1e3 + this.client.options.restTimeOffset);\n            }\n          } else {\n            item.reject(err.status >= 400 && err.status < 500 ? new DiscordAPIError(res.request.path, res.body, res.request.method) : err);\n            resolve(err);\n          }\n        } else {\n          this.globalLimit = false;\n          const data = res && res.body ? res.body : {};\n          item.resolve(data);\n\n          if (this.requestRemaining === 0) {\n            if (this.client.listenerCount(RATE_LIMIT)) {\n              /**\n               * Emitted when the client hits a rate limit while making a request\n               * @event Client#rateLimit\n               * @param {Object} rateLimitInfo Object containing the rate limit info\n               * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint\n               * @param {number} rateLimitInfo.timeDifference Delta-T in ms between your system and Discord servers\n               * @param {string} rateLimitInfo.path Path used for request that triggered this event\n               * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event\n               */\n              this.client.emit(RATE_LIMIT, {\n                limit: this.requestLimit,\n                timeDifference: this.timeDifference,\n                path: item.request.path,\n                method: item.request.method\n              });\n            }\n\n            this.client.setTimeout(() => resolve(data), this.requestResetTime - Date.now() + this.timeDifference + this.client.options.restTimeOffset);\n          } else {\n            resolve(data);\n          }\n        }\n      });\n    });\n  }\n\n  handle() {\n    super.handle();\n    if (this.busy || this.remaining === 0 || this.queue.length === 0 || this.globalLimit) return;\n    this.execute(this.queue.shift()).then(() => {\n      this.busy = false;\n      this.handle();\n    });\n  }\n\n}\n\nmodule.exports = SequentialRequestHandler;","map":null,"metadata":{},"sourceType":"script"}