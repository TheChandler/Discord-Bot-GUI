{"ast":null,"code":"const Mentions = require('./MessageMentions');\n\nconst Attachment = require('./MessageAttachment');\n\nconst Embed = require('./MessageEmbed');\n\nconst RichEmbed = require('./RichEmbed');\n\nconst MessageReaction = require('./MessageReaction');\n\nconst ReactionCollector = require('./ReactionCollector');\n\nconst Util = require('../util/Util');\n\nconst Collection = require('../util/Collection');\n\nconst Constants = require('../util/Constants');\n\nconst Permissions = require('../util/Permissions');\n\nlet GuildMember;\n/**\n * Represents a message on Discord.\n */\n\nclass Message {\n  constructor(channel, data, client) {\n    /**\n     * The client that instantiated the Message\n     * @name Message#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The channel that the message was sent in\n     * @type {TextChannel|DMChannel|GroupDMChannel}\n     */\n\n    this.channel = channel;\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    if (data) this.setup(data);\n  }\n\n  setup(data) {\n    // eslint-disable-line complexity\n\n    /**\n     * The ID of the message\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The type of the message\n     * @type {MessageType}\n     */\n\n    this.type = Constants.MessageTypes[data.type];\n    /**\n     * The content of the message\n     * @type {string}\n     */\n\n    this.content = data.content;\n    /**\n     * The author of the message\n     * @type {User}\n     */\n\n    this.author = this.client.dataManager.newUser(data.author, !data.webhook_id);\n    /**\n     * Represents the author of the message as a guild member\n     * Only available if the message comes from a guild where the author is still a member\n     * @type {?GuildMember}\n     */\n\n    this.member = this.guild ? this.guild.member(this.author) || null : null;\n    /**\n     * Whether or not this message is pinned\n     * @type {boolean}\n     */\n\n    this.pinned = data.pinned;\n    /**\n     * Whether or not the message was Text-To-Speech\n     * @type {boolean}\n     */\n\n    this.tts = data.tts;\n    /**\n     * A random number or string used for checking message delivery\n     * @type {string}\n     */\n\n    this.nonce = data.nonce;\n    /**\n     * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n     * @type {boolean}\n     */\n\n    this.system = data.type === 6;\n    /**\n     * A list of embeds in the message - e.g. YouTube Player\n     * @type {MessageEmbed[]}\n     */\n\n    this.embeds = data.embeds.map(e => new Embed(this, e));\n    /**\n     * A collection of attachments in the message - e.g. Pictures - mapped by their ID\n     * @type {Collection<Snowflake, MessageAttachment>}\n     */\n\n    this.attachments = new Collection();\n\n    for (const attachment of data.attachments) this.attachments.set(attachment.id, new Attachment(this, attachment));\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n\n\n    this.createdTimestamp = new Date(data.timestamp).getTime();\n    /**\n     * The timestamp the message was last edited at (if applicable)\n     * @type {?number}\n     */\n\n    this.editedTimestamp = data.edited_timestamp ? new Date(data.edited_timestamp).getTime() : null;\n    /**\n     * A collection of reactions to this message, mapped by the reaction ID\n     * @type {Collection<Snowflake, MessageReaction>}\n     */\n\n    this.reactions = new Collection();\n\n    if (data.reactions && data.reactions.length > 0) {\n      for (const reaction of data.reactions) {\n        const id = reaction.emoji.id ? \"\".concat(reaction.emoji.name, \":\").concat(reaction.emoji.id) : reaction.emoji.name;\n        this.reactions.set(id, new MessageReaction(this, reaction.emoji, reaction.count, reaction.me));\n      }\n    }\n    /**\n     * All valid mentions that the message contains\n     * @type {MessageMentions}\n     */\n\n\n    this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone);\n    /**\n     * ID of the webhook that sent the message, if applicable\n     * @type {?Snowflake}\n     */\n\n    this.webhookID = data.webhook_id || null;\n    /**\n     * Whether this message is a hit in a search\n     * @type {?boolean}\n     */\n\n    this.hit = typeof data.hit === 'boolean' ? data.hit : null;\n    /**\n     * The previous versions of the message, sorted with the most recent first\n     * @type {Message[]}\n     * @private\n     */\n\n    this._edits = [];\n  }\n  /**\n   * Updates the message.\n   * @param {Object} data Raw Discord message update data\n   * @private\n   */\n\n\n  patch(data) {\n    const clone = Util.cloneObject(this);\n\n    this._edits.unshift(clone);\n\n    if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n    if ('content' in data) this.content = data.content;\n    if ('pinned' in data) this.pinned = data.pinned;\n    if ('tts' in data) this.tts = data.tts;\n    if ('embeds' in data) this.embeds = data.embeds.map(e => new Embed(this, e));else this.embeds = this.embeds.slice();\n\n    if ('attachments' in data) {\n      this.attachments = new Collection();\n\n      for (const attachment of data.attachments) this.attachments.set(attachment.id, new Attachment(this, attachment));\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    this.mentions = new Mentions(this, 'mentions' in data ? data.mentions : this.mentions.users, 'mentions_roles' in data ? data.mentions_roles : this.mentions.roles, 'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone);\n  }\n  /**\n   * The time the message was sent\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n\n\n  get guild() {\n    return this.channel.guild || null;\n  }\n  /**\n   * The url to jump to the message\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return \"https://discordapp.com/channels/\".concat(this.guild ? this.guild.id : '@me', \"/\").concat(this.channel.id, \"/\").concat(this.id);\n  }\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {string}\n   * @readonly\n   */\n\n\n  get cleanContent() {\n    return this.content.replace(/@(everyone|here)/g, '@\\u200b$1').replace(/<@!?[0-9]+>/g, input => {\n      const id = input.replace(/<|!|>|@/g, '');\n\n      if (this.channel.type === 'dm' || this.channel.type === 'group') {\n        return this.client.users.has(id) ? \"@\".concat(this.client.users.get(id).username) : input;\n      }\n\n      const member = this.channel.guild.members.get(id);\n\n      if (member) {\n        if (member.nickname) return \"@\".concat(member.nickname);\n        return \"@\".concat(member.user.username);\n      } else {\n        const user = this.client.users.get(id);\n        if (user) return \"@\".concat(user.username);\n        return input;\n      }\n    }).replace(/<#[0-9]+>/g, input => {\n      const channel = this.client.channels.get(input.replace(/<|#|>/g, ''));\n      if (channel) return \"#\".concat(channel.name);\n      return input;\n    }).replace(/<@&[0-9]+>/g, input => {\n      if (this.channel.type === 'dm' || this.channel.type === 'group') return input;\n      const role = this.guild.roles.get(input.replace(/<|@|>|&/g, ''));\n      if (role) return \"@\".concat(role.name);\n      return input;\n    });\n  }\n  /**\n   * Creates a reaction collector.\n   * @param {CollectorFilter} filter The filter to apply\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someID'\n   * const collector = message.createReactionCollector(filter, { time: 15000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createReactionCollector(filter, options = {}) {\n    return new ReactionCollector(this, filter, options);\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someID'\n   * message.awaitReactions(filter, { time: 15000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n\n\n  awaitReactions(filter, options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(filter, options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors && options.errors.includes(reason)) reject(reactions);else resolve(reactions);\n      });\n    });\n  }\n  /**\n   * An array of cached versions of the message, including the current version\n   * Sorted from latest (first) to oldest (last)\n   * @type {Message[]}\n   * @readonly\n   */\n\n\n  get edits() {\n    const copy = this._edits.slice();\n\n    copy.unshift(this);\n    return copy;\n  }\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    return this.author.id === this.client.user.id;\n  }\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return !this.deleted && (this.author.id === this.client.user.id || this.guild && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES));\n  }\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get pinnable() {\n    return this.type === 'DEFAULT' && (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES));\n  }\n  /**\n   * Whether or not a user, channel or role is mentioned in this message.\n   * @param {GuildChannel|User|Role|string} data Either a guild channel, user or a role object, or a string representing\n   * the ID of any of these\n   * @returns {boolean}\n   */\n\n\n  isMentioned(data) {\n    data = data && data.id ? data.id : data;\n    return this.mentions.users.has(data) || this.mentions.channels.has(data) || this.mentions.roles.has(data);\n  }\n  /**\n   * Whether or not a guild member is mentioned in this message. Takes into account\n   * user mentions, role mentions, and @everyone/@here mentions.\n   * @param {GuildMember|User} member The member/user to check for a mention of\n   * @returns {boolean}\n   */\n\n\n  isMemberMentioned(member) {\n    // Lazy-loading is used here to get around a circular dependency that breaks things\n    if (!GuildMember) GuildMember = require('./GuildMember');\n    if (this.mentions.everyone) return true;\n    if (this.mentions.users.has(member.id)) return true;\n    if (member instanceof GuildMember && member.roles.some(r => this.mentions.roles.has(r.id))) return true;\n    return false;\n  }\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} MessageEditOptions\n   * @property {Object} [embed] An embed to be added/edited\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   */\n\n  /**\n   * Edit the content of the message.\n   * @param {StringResolvable} [content] The new content for the message\n   * @param {MessageEditOptions|RichEmbed} [options] The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`New message content: ${msg}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(content, options) {\n    if (!options && typeof content === 'object' && !(content instanceof Array)) {\n      options = content;\n      content = '';\n    } else if (!options) {\n      options = {};\n    }\n\n    if (options instanceof RichEmbed) options = {\n      embed: options\n    };\n    return this.client.rest.methods.updateMessage(this, content, options);\n  }\n  /**\n   * Edit the content of the message, with a code block.\n   * @param {string} lang The language for the code block\n   * @param {StringResolvable} content The new content for the message\n   * @returns {Promise<Message>}\n   * @deprecated\n   */\n\n\n  editCode(lang, content) {\n    content = Util.escapeMarkdown(this.client.resolver.resolveString(content), true);\n    return this.edit(\"```\".concat(lang || '', \"\\n\").concat(content, \"\\n```\"));\n  }\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @returns {Promise<Message>}\n   */\n\n\n  pin() {\n    return this.client.rest.methods.pinMessage(this);\n  }\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @returns {Promise<Message>}\n   */\n\n\n  unpin() {\n    return this.client.rest.methods.unpinMessage(this);\n  }\n  /**\n   * Add a reaction to the message.\n   * @param {string|Emoji|ReactionEmoji} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('ðŸ¤”')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  react(emoji) {\n    emoji = this.client.resolver.resolveEmojiIdentifier(emoji);\n    if (!emoji) throw new TypeError('Emoji must be a string or Emoji/ReactionEmoji');\n    return this.client.rest.methods.addMessageReaction(this, emoji);\n  }\n  /**\n   * Remove all reactions from a message.\n   * @returns {Promise<Message>}\n   */\n\n\n  clearReactions() {\n    return this.client.rest.methods.removeMessageReactions(this);\n  }\n  /**\n   * Deletes the message.\n   * @param {number} [timeout=0] How long to wait to delete the message in milliseconds\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n\n\n  delete(timeout = 0) {\n    if (timeout <= 0) {\n      return this.client.rest.methods.deleteMessage(this);\n    } else {\n      return new Promise(resolve => {\n        this.client.setTimeout(() => {\n          resolve(this.delete());\n        }, timeout);\n      });\n    }\n  }\n  /**\n   * Reply to the message.\n   * @param {StringResolvable} [content] The content for the message\n   * @param {MessageOptions} [options] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Reply to a message\n   * message.reply('Hey, I\\'m a reply!')\n   *   .then(sent => console.log(`Sent a reply to ${sent.author.username}`))\n   *   .catch(console.error);\n   */\n\n\n  reply(content, options) {\n    if (!options && typeof content === 'object' && !(content instanceof Array)) {\n      options = content;\n      content = '';\n    } else if (!options) {\n      options = {};\n    }\n\n    return this.channel.send(content, Object.assign(options, {\n      reply: this.member || this.author\n    }));\n  }\n  /**\n   * Marks the message as read.\n   * <warn>This is only available when using a user account.</warn>\n   * @returns {Promise<Message>}\n   * @deprecated\n   */\n\n\n  acknowledge() {\n    return this.client.rest.methods.ackMessage(this);\n  }\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n\n\n  fetchWebhook() {\n    if (!this.webhookID) return Promise.reject(new Error('The message was not sent by a webhook.'));\n    return this.client.fetchWebhook(this.webhookID);\n  }\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {Object} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n\n\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n    let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n\n\n  toString() {\n    return this.content;\n  }\n\n  _addReaction(emoji, user) {\n    const emojiID = emoji.id ? \"\".concat(emoji.name, \":\").concat(emoji.id) : emoji.name;\n    let reaction;\n\n    if (this.reactions.has(emojiID)) {\n      reaction = this.reactions.get(emojiID);\n      if (!reaction.me) reaction.me = user.id === this.client.user.id;\n    } else {\n      reaction = new MessageReaction(this, emoji, 0, user.id === this.client.user.id);\n      this.reactions.set(emojiID, reaction);\n    }\n\n    if (!reaction.users.has(user.id)) {\n      reaction.users.set(user.id, user);\n      reaction.count++;\n    }\n\n    return reaction;\n  }\n\n  _removeReaction(emoji, user) {\n    const emojiID = emoji.id ? \"\".concat(emoji.name, \":\").concat(emoji.id) : emoji.name;\n\n    if (this.reactions.has(emojiID)) {\n      const reaction = this.reactions.get(emojiID);\n\n      if (reaction.users.has(user.id)) {\n        reaction.users.delete(user.id);\n        reaction.count--;\n        if (user.id === this.client.user.id) reaction.me = false;\n        if (reaction.count <= 0) this.reactions.delete(emojiID);\n        return reaction;\n      }\n    }\n\n    return null;\n  }\n\n  _clearReactions() {\n    this.reactions.clear();\n  }\n\n}\n\nmodule.exports = Message;","map":null,"metadata":{},"sourceType":"script"}