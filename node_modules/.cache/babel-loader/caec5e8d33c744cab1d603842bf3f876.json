{"ast":null,"code":"const Collection = require('../../util/Collection');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {number} [time] How long to run the collector for\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\n\n\nclass Collector extends EventEmitter {\n  constructor(client, filter, options = {}) {\n    super();\n    /**\n     * The client\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     */\n\n    this.filter = filter;\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n\n    this.options = options;\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n\n    this.collected = new Collection();\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n\n    this.ended = false;\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n\n    this._timeout = null;\n    /**\n     * Call this to handle an event as a collectable element\n     * Accepts any event data as parameters\n     * @type {Function}\n     * @private\n     */\n\n    this.listener = this._handle.bind(this);\n    if (options.time) this._timeout = this.client.setTimeout(() => this.stop('time'), options.time);\n  }\n  /**\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#collect\n   * @private\n   */\n\n\n  _handle(...args) {\n    const collect = this.handle(...args);\n    if (!collect || !this.filter(...args, this.collected)) return;\n    this.collected.set(collect.key, collect.value);\n    /**\n     * Emitted whenever an element is collected.\n     * @event Collector#collect\n     * @param {*} element The element that got collected\n     * @param {Collector} collector The collector\n     */\n\n    this.emit('collect', collect.value, this);\n    const post = this.postCheck(...args);\n    if (post) this.stop(post);\n  }\n  /**\n   * Return a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n\n\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n  /**\n   * Stop this collector and emit the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n\n\n  stop(reason = 'user') {\n    if (this.ended) return;\n    if (this._timeout) this.client.clearTimeout(this._timeout);\n    this.ended = true;\n    this.cleanup();\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n\n    this.emit('end', this.collected, reason);\n  }\n  /* eslint-disable no-empty-function, valid-jsdoc */\n\n  /**\n   * Handles incoming events from the `listener` function. Returns null if the event should not be collected,\n   * or returns an object describing the data that should be stored.\n   * @see Collector#listener\n   * @param {...*} args Any args the event listener emits\n   * @returns {?{key: string, value}} Data to insert into collection, if any\n   * @abstract\n   */\n\n\n  handle() {}\n  /**\n   * This method runs after collection to see if the collector should finish.\n   * @param {...*} args Any args the event listener emits\n   * @returns {?string} Reason to end the collector, if any\n   * @abstract\n   */\n\n\n  postCheck() {}\n  /**\n   * Called when the collector is ending.\n   * @abstract\n   */\n\n\n  cleanup() {}\n  /* eslint-enable no-empty-function, valid-jsdoc */\n\n\n}\n\nmodule.exports = Collector;","map":null,"metadata":{},"sourceType":"script"}