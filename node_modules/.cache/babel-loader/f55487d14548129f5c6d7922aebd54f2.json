{"ast":null,"code":"const TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst Constants = require('../util/Constants');\n\nconst Presence = require('./Presence').Presence;\n\nconst Snowflake = require('../util/Snowflake');\n\nconst util = require('util');\n/**\n * Represents a user on Discord.\n * @implements {TextBasedChannel}\n */\n\n\nclass User {\n  constructor(client, data) {\n    /**\n     * The client that created the instance of the user\n     * @name User#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    if (data) this.setup(data);\n  }\n\n  setup(data) {\n    /**\n     * The ID of the user\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The username of the user\n     * @type {string}\n     */\n\n    this.username = data.username;\n    /**\n     * A discriminator based on username for the user\n     * @type {string}\n     */\n\n    this.discriminator = data.discriminator;\n    /**\n     * The ID of the user's avatar\n     * @type {string}\n     */\n\n    this.avatar = data.avatar;\n    /**\n     * Whether or not the user is a bot\n     * @type {boolean}\n     */\n\n    this.bot = Boolean(data.bot);\n    /**\n     * The ID of the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = null;\n    /**\n     * The Message object of the last message sent by the user, if one was sent\n     * @type {?Message}\n     */\n\n    this.lastMessage = null;\n  }\n\n  patch(data) {\n    for (const prop of ['id', 'username', 'discriminator', 'avatar', 'bot']) {\n      if (typeof data[prop] !== 'undefined') this[prop] = data[prop];\n    }\n\n    if (data.token) this.client.token = data.token;\n  }\n  /**\n   * The timestamp the user was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the user was created\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The presence of this user\n   * @type {Presence}\n   * @readonly\n   */\n\n\n  get presence() {\n    if (this.client.presences.has(this.id)) return this.client.presences.get(this.id);\n\n    for (const guild of this.client.guilds.values()) {\n      if (guild.presences.has(this.id)) return guild.presences.get(this.id);\n    }\n\n    return new Presence(undefined, this.client);\n  }\n  /**\n   * A link to the user's avatar\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get avatarURL() {\n    if (!this.avatar) return null;\n    return Constants.Endpoints.User(this).Avatar(this.client.options.http.cdn, this.avatar);\n  }\n  /**\n   * A link to the user's default avatar\n   * @type {string}\n   * @readonly\n   */\n\n\n  get defaultAvatarURL() {\n    const avatars = Object.keys(Constants.DefaultAvatars);\n    const avatar = avatars[this.discriminator % avatars.length];\n    return Constants.Endpoints.CDN(this.client.options.http.host).Asset(\"\".concat(Constants.DefaultAvatars[avatar], \".png\"));\n  }\n  /**\n   * A link to the user's avatar if they have one. Otherwise a link to their default avatar will be returned\n   * @type {string}\n   * @readonly\n   */\n\n\n  get displayAvatarURL() {\n    return this.avatarURL || this.defaultAvatarURL;\n  }\n  /**\n   * The Discord \"tag\" (e.g. `hydrabolt#0001`) for this user\n   * @type {string}\n   * @readonly\n   */\n\n\n  get tag() {\n    return \"\".concat(this.username, \"#\").concat(this.discriminator);\n  }\n  /**\n   * The note that is set for the user\n   * <warn>This is only available when using a user account.</warn>\n   * @type {?string}\n   * @readonly\n   * @deprecated\n   */\n\n\n  get note() {\n    return this.client.user.notes.get(this.id) || null;\n  }\n  /**\n   * Check whether the user is typing in a channel.\n   * @param {ChannelResolvable} channel The channel to check in\n   * @returns {boolean}\n   */\n\n\n  typingIn(channel) {\n    channel = this.client.resolver.resolveChannel(channel);\n    return channel._typing.has(this.id);\n  }\n  /**\n   * Get the time that the user started typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {?Date}\n   */\n\n\n  typingSinceIn(channel) {\n    channel = this.client.resolver.resolveChannel(channel);\n    return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;\n  }\n  /**\n   * Get the amount of time the user has been typing in a channel for (in milliseconds), or -1 if they're not typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {number}\n   */\n\n\n  typingDurationIn(channel) {\n    channel = this.client.resolver.resolveChannel(channel);\n    return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;\n  }\n  /**\n   * The DM between the client's user and this user\n   * @type {?DMChannel}\n   * @readonly\n   */\n\n\n  get dmChannel() {\n    return this.client.channels.find(c => c.type === 'dm' && c.recipient.id === this.id);\n  }\n  /**\n   * Creates a DM channel between the client and the user.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  createDM() {\n    return this.client.rest.methods.createDM(this);\n  }\n  /**\n   * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  deleteDM() {\n    return this.client.rest.methods.deleteChannel(this);\n  }\n  /**\n   * Sends a friend request to the user.\n   * <warn>This is only available when using a user account.</warn>\n   * @returns {Promise<User>}\n   * @deprecated\n   */\n\n\n  addFriend() {\n    return this.client.rest.methods.addFriend(this);\n  }\n  /**\n   * Removes the user from your friends.\n   * <warn>This is only available when using a user account.</warn>\n   * @returns {Promise<User>}\n   * @deprecated\n   */\n\n\n  removeFriend() {\n    return this.client.rest.methods.removeFriend(this);\n  }\n  /**\n   * Blocks the user.\n   * <warn>This is only available when using a user account.</warn>\n   * @returns {Promise<User>}\n   * @deprecated\n   */\n\n\n  block() {\n    return this.client.rest.methods.blockUser(this);\n  }\n  /**\n   * Unblocks the user.\n   * <warn>This is only available when using a user account.</warn>\n   * @returns {Promise<User>}\n   * @deprecated\n   */\n\n\n  unblock() {\n    return this.client.rest.methods.unblockUser(this);\n  }\n  /**\n   * Get the profile of the user.\n   * <warn>This is only available when using a user account.</warn>\n   * @returns {Promise<UserProfile>}\n   * @deprecated\n   */\n\n\n  fetchProfile() {\n    return this.client.rest.methods.fetchUserProfile(this);\n  }\n  /**\n   * Sets a note for the user.\n   * <warn>This is only available when using a user account.</warn>\n   * @param {string} note The note to set for the user\n   * @returns {Promise<User>}\n   * @deprecated\n   */\n\n\n  setNote(note) {\n    return this.client.rest.methods.setNote(this, note);\n  }\n  /**\n   * Checks if the user is equal to another. It compares ID, username, discriminator, avatar, and bot flags.\n   * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.\n   * @param {User} user User to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(user) {\n    let equal = user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar && this.bot === Boolean(user.bot);\n    return equal;\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the user's mention instead of the User object.\n   * @returns {string}\n   * @example\n   * // logs: Hello from <@123456789>!\n   * console.log(`Hello from ${user}!`);\n   */\n\n\n  toString() {\n    return \"<@\".concat(this.id, \">\");\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  send() {}\n\n  sendMessage() {}\n\n  sendEmbed() {}\n\n  sendFile() {}\n\n  sendCode() {}\n\n}\n\nTextBasedChannel.applyToClass(User);\nUser.prototype.block = util.deprecate(User.prototype.block, 'User#block: userbot methods will be removed');\nUser.prototype.unblock = util.deprecate(User.prototype.unblock, 'User#unblock: userbot methods will be removed');\nUser.prototype.addFriend = util.deprecate(User.prototype.addFriend, 'User#addFriend: userbot methods will be removed');\nUser.prototype.removeFriend = util.deprecate(User.prototype.removeFriend, 'User#removeFriend: userbot methods will be removed');\nUser.prototype.setNote = util.deprecate(User.prototype.setNote, 'User#setNote, userbot methods will be removed');\nUser.prototype.fetchProfile = util.deprecate(User.prototype.fetchProfile, 'User#fetchProfile: userbot methods will be removed');\nmodule.exports = User;","map":null,"metadata":{},"sourceType":"script"}