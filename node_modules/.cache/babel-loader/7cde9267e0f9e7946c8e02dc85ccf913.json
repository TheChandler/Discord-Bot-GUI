{"ast":null,"code":"const Constants = require('../util/Constants');\n\nconst Collection = require('../util/Collection');\n\nconst Permissions = require('../util/Permissions');\n\nconst Snowflake = require('../util/Snowflake');\n/**\n * Represents a custom emoji.\n */\n\n\nclass Emoji {\n  constructor(guild, data) {\n    /**\n     * The client that instantiated this object\n     * @name Emoji#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: guild.client\n    });\n    /**\n     * The guild this emoji is part of\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * Whether this emoji has been deleted\n     * @type {boolean}\n     */\n\n    this.deleted = false;\n    this.setup(data);\n  }\n\n  setup(data) {\n    /**\n     * The ID of the emoji\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The name of the emoji\n     * @type {string}\n     */\n\n    this.name = data.name;\n    /**\n     * Whether or not this emoji requires colons surrounding it\n     * @type {boolean}\n     */\n\n    this.requiresColons = data.require_colons;\n    /**\n     * Whether this emoji is managed by an external service\n     * @type {boolean}\n     */\n\n    this.managed = data.managed;\n    /**\n     * Whether this emoji is animated\n     * @type {boolean}\n     */\n\n    this.animated = data.animated;\n    this._roles = data.roles;\n  }\n  /**\n   * The timestamp the emoji was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n  /**\n   * The time the emoji was created\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * Whether the emoji is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return !this.managed && this.guild.me.hasPermission(Permissions.FLAGS.MANAGE_EMOJIS);\n  }\n  /**\n   * A collection of roles this emoji is active for (empty if all), mapped by role ID\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n\n\n  get roles() {\n    const roles = new Collection();\n\n    for (const role of this._roles) {\n      if (this.guild.roles.has(role)) roles.set(role, this.guild.roles.get(role));\n    }\n\n    return roles;\n  }\n  /**\n   * The URL to the emoji file\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return Constants.Endpoints.CDN(this.client.options.http.cdn).Emoji(this.id, this.animated ? 'gif' : 'png');\n  }\n  /**\n   * The identifier of this emoji, used for message reactions\n   * @type {string}\n   * @readonly\n   */\n\n\n  get identifier() {\n    if (this.id) return \"\".concat(this.name, \":\").concat(this.id);\n    return encodeURIComponent(this.name);\n  }\n  /**\n   * Data for editing an emoji.\n   * @typedef {Object} EmojiEditData\n   * @property {string} [name] The name of the emoji\n   * @property {Collection<Snowflake, Role>|Array<Snowflake|Role>} [roles] Roles to restrict emoji to\n   */\n\n  /**\n   * Edits the emoji.\n   * @param {EmojiEditData} data The new data for the emoji\n   * @param {string} [reason] Reason for editing this emoji\n   * @returns {Promise<Emoji>}\n   * @example\n   * // Edit an emoji\n   * emoji.edit({name: 'newemoji'})\n   *   .then(e => console.log(`Edited emoji ${e}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(data, reason) {\n    return this.client.rest.methods.updateEmoji(this, data, reason);\n  }\n  /**\n   * Set the name of the emoji.\n   * @param {string} name The new name for the emoji\n   * @param {string} [reason] The reason for changing the emoji's name\n   * @returns {Promise<Emoji>}\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Fetches the author for this emoji\n   * @returns {Promise<User>}\n   */\n\n\n  fetchAuthor() {\n    if (this.managed) return Promise.reject(new Error('Emoji is managed and has no Author.'));\n\n    if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) {\n      return Promise.reject(new Error(\"Client must have Manage Emoji permission in guild \".concat(this.guild, \" to see emoji authors.\")));\n    }\n\n    return this.client.rest.makeRequest('get', Constants.Endpoints.Guild(this.guild).Emoji(this.id), true).then(emoji => this.client.dataManager.newUser(emoji.user));\n  }\n  /**\n   * Add a role to the list of roles that can use this emoji.\n   * @param {Role} role The role to add\n   * @returns {Promise<Emoji>}\n   */\n\n\n  addRestrictedRole(role) {\n    return this.addRestrictedRoles([role]);\n  }\n  /**\n   * Add multiple roles to the list of roles that can use this emoji.\n   * @param {Role[]} roles Roles to add\n   * @returns {Promise<Emoji>}\n   */\n\n\n  addRestrictedRoles(roles) {\n    const newRoles = new Collection(this.roles);\n\n    for (const role of roles) {\n      if (this.guild.roles.has(role.id)) newRoles.set(role.id, role);\n    }\n\n    return this.edit({\n      roles: newRoles\n    });\n  }\n  /**\n   * Remove a role from the list of roles that can use this emoji.\n   * @param {Role} role The role to remove\n   * @returns {Promise<Emoji>}\n   */\n\n\n  removeRestrictedRole(role) {\n    return this.removeRestrictedRoles([role]);\n  }\n  /**\n   * Remove multiple roles from the list of roles that can use this emoji.\n   * @param {Role[]} roles Roles to remove\n   * @returns {Promise<Emoji>}\n   */\n\n\n  removeRestrictedRoles(roles) {\n    const newRoles = new Collection(this.roles);\n\n    for (const role of roles) {\n      if (newRoles.has(role.id)) newRoles.delete(role.id);\n    }\n\n    return this.edit({\n      roles: newRoles\n    });\n  }\n  /**\n   * When concatenated with a string, this automatically returns the emoji mention rather than the object.\n   * @returns {string}\n   * @example\n   * // Send an emoji:\n   * const emoji = guild.emojis.first();\n   * msg.reply(`Hello! ${emoji}`);\n   */\n\n\n  toString() {\n    if (!this.id || !this.requiresColons) {\n      return this.name;\n    }\n\n    return \"<\".concat(this.animated ? 'a' : '', \":\").concat(this.name, \":\").concat(this.id, \">\");\n  }\n  /**\n   * Whether this emoji is the same as another one.\n   * @param {Emoji|Object} other The emoji to compare it to\n   * @returns {boolean} Whether the emoji is equal to the given emoji or not\n   */\n\n\n  equals(other) {\n    if (other instanceof Emoji) {\n      return other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons;\n    } else {\n      return other.id === this.id && other.name === this.name;\n    }\n  }\n\n}\n\nmodule.exports = Emoji;","map":null,"metadata":{},"sourceType":"script"}