{"ast":null,"code":"const querystring = require('querystring');\n\nconst long = require('long');\n\nconst Permissions = require('../../util/Permissions');\n\nconst Constants = require('../../util/Constants');\n\nconst Endpoints = Constants.Endpoints;\n\nconst Collection = require('../../util/Collection');\n\nconst Util = require('../../util/Util');\n\nconst resolvePermissions = require('../../structures/shared/resolvePermissions');\n\nconst RichEmbed = require('../../structures/RichEmbed');\n\nconst User = require('../../structures/User');\n\nconst GuildMember = require('../../structures/GuildMember');\n\nconst Message = require('../../structures/Message');\n\nconst Role = require('../../structures/Role');\n\nconst Invite = require('../../structures/Invite');\n\nconst Webhook = require('../../structures/Webhook');\n\nconst UserProfile = require('../../structures/UserProfile');\n\nconst OAuth2Application = require('../../structures/OAuth2Application');\n\nconst Channel = require('../../structures/Channel');\n\nconst GroupDMChannel = require('../../structures/GroupDMChannel');\n\nconst Guild = require('../../structures/Guild');\n\nconst VoiceRegion = require('../../structures/VoiceRegion');\n\nconst GuildAuditLogs = require('../../structures/GuildAuditLogs');\n\nclass RESTMethods {\n  constructor(restManager) {\n    this.rest = restManager;\n    this.client = restManager.client;\n    this._ackToken = null;\n  }\n\n  login(token = this.client.token) {\n    return new Promise((resolve, reject) => {\n      if (!token || typeof token !== 'string') throw new Error(Constants.Errors.INVALID_TOKEN);\n      token = token.replace(/^Bot\\s*/i, '');\n      this.client.manager.connectToWebSocket(token, resolve, reject);\n    }).catch(e => {\n      this.client.destroy();\n      return Promise.reject(e);\n    });\n  }\n\n  logout() {\n    return this.rest.makeRequest('post', Endpoints.logout, true, {});\n  }\n\n  getGateway(bot = false) {\n    return this.rest.makeRequest('get', bot ? Endpoints.gateway.bot : Endpoints.gateway, true);\n  }\n\n  fetchVoiceRegions(guildID) {\n    let endpoint;\n    if (guildID) endpoint = Endpoints.Guild(guildID).voiceRegions;else endpoint = Endpoints.voiceRegions;\n    return this.rest.makeRequest('get', endpoint, true).then(res => {\n      const regions = new Collection();\n\n      for (const region of res) regions.set(region.id, new VoiceRegion(region));\n\n      return regions;\n    });\n  }\n\n  fetchEmbed(guildID) {\n    return this.rest.makeRequest('get', Endpoints.Guild(guildID).embed, true).then(data => ({\n      enabled: data.enabled,\n      channel: data.channel_id ? this.client.channels.get(data.channel_id) : null\n    }));\n  }\n\n  sendMessage(channel, content, {\n    tts,\n    nonce,\n    embed,\n    disableEveryone,\n    split,\n    code,\n    reply\n  } = {}, files = null) {\n    return new Promise((resolve, reject) => {\n      // eslint-disable-line complexity\n      if (typeof content !== 'undefined') content = this.client.resolver.resolveString(content); // The nonce has to be a uint64 :<\n\n      if (typeof nonce !== 'undefined') {\n        nonce = parseInt(nonce);\n        if (isNaN(nonce) || nonce < 0) throw new RangeError('Message nonce must fit in an unsigned 64-bit integer.');\n      }\n\n      if (content) {\n        if (split && typeof split !== 'object') split = {}; // Wrap everything in a code block\n\n        if (typeof code !== 'undefined' && (typeof code !== 'boolean' || code === true)) {\n          content = Util.escapeMarkdown(this.client.resolver.resolveString(content), true);\n          content = \"```\".concat(typeof code !== 'boolean' ? code || '' : '', \"\\n\").concat(content, \"\\n```\");\n\n          if (split) {\n            split.prepend = \"```\".concat(typeof code !== 'boolean' ? code || '' : '', \"\\n\");\n            split.append = '\\n```';\n          }\n        } // Add zero-width spaces to @everyone/@here\n\n\n        if (disableEveryone || typeof disableEveryone === 'undefined' && this.client.options.disableEveryone) {\n          content = content.replace(/@(everyone|here)/g, '@\\u200b$1');\n        } // Add the reply prefix\n\n\n        if (reply && !(channel instanceof User || channel instanceof GuildMember) && channel.type !== 'dm') {\n          const id = this.client.resolver.resolveUserID(reply);\n          const mention = \"<@\".concat(reply instanceof GuildMember && reply.nickname ? '!' : '').concat(id, \">\");\n          content = \"\".concat(mention).concat(content ? \", \".concat(content) : '');\n          if (split) split.prepend = \"\".concat(mention, \", \").concat(split.prepend || '');\n        } // Split the content\n\n\n        if (split) content = Util.splitMessage(content, split);\n      } else if (reply && !(channel instanceof User || channel instanceof GuildMember) && channel.type !== 'dm') {\n        const id = this.client.resolver.resolveUserID(reply);\n        content = \"<@\".concat(reply instanceof GuildMember && reply.nickname ? '!' : '').concat(id, \">\");\n      }\n\n      const send = chan => {\n        if (content instanceof Array) {\n          const messages = [];\n\n          (function sendChunk(list, index) {\n            const options = index === list.length - 1 ? {\n              tts,\n              embed,\n              files\n            } : {\n              tts\n            };\n            chan.send(list[index], options).then(message => {\n              messages.push(message);\n              if (index >= list.length - 1) return resolve(messages);\n              return sendChunk(list, ++index);\n            }).catch(reject);\n          })(content, 0);\n        } else {\n          this.rest.makeRequest('post', Endpoints.Channel(chan).messages, true, {\n            content,\n            tts,\n            nonce,\n            embed\n          }, files).then(data => resolve(this.client.actions.MessageCreate.handle(data).message), reject);\n        }\n      };\n\n      if (channel instanceof User || channel instanceof GuildMember) this.createDM(channel).then(send, reject);else send(channel);\n    });\n  }\n\n  updateMessage(message, content, {\n    embed,\n    code,\n    reply\n  } = {}) {\n    if (typeof content !== 'undefined') content = this.client.resolver.resolveString(content); // Wrap everything in a code block\n\n    if (typeof code !== 'undefined' && (typeof code !== 'boolean' || code === true)) {\n      content = Util.escapeMarkdown(this.client.resolver.resolveString(content), true);\n      content = \"```\".concat(typeof code !== 'boolean' ? code || '' : '', \"\\n\").concat(content, \"\\n```\");\n    } // Add the reply prefix\n\n\n    if (reply && message.channel.type !== 'dm') {\n      const id = this.client.resolver.resolveUserID(reply);\n      const mention = \"<@\".concat(reply instanceof GuildMember && reply.nickname ? '!' : '').concat(id, \">\");\n      content = \"\".concat(mention).concat(content ? \", \".concat(content) : '');\n    }\n\n    if (embed instanceof RichEmbed) embed = embed._apiTransform();\n    return this.rest.makeRequest('patch', Endpoints.Message(message), true, {\n      content,\n      embed\n    }).then(data => this.client.actions.MessageUpdate.handle(data).updated);\n  }\n\n  deleteMessage(message) {\n    return this.rest.makeRequest('delete', Endpoints.Message(message), true).then(() => this.client.actions.MessageDelete.handle({\n      id: message.id,\n      channel_id: message.channel.id\n    }).message);\n  }\n\n  ackMessage(message) {\n    return this.rest.makeRequest('post', Endpoints.Message(message).ack, true, {\n      token: this._ackToken\n    }).then(res => {\n      if (res.token) this._ackToken = res.token;\n      return message;\n    });\n  }\n\n  ackTextChannel(channel) {\n    return this.rest.makeRequest('post', Endpoints.Channel(channel).Message(channel.lastMessageID).ack, true, {\n      token: this._ackToken\n    }).then(res => {\n      if (res.token) this._ackToken = res.token;\n      return channel;\n    });\n  }\n\n  ackGuild(guild) {\n    return this.rest.makeRequest('post', Endpoints.Guild(guild).ack, true).then(() => guild);\n  }\n\n  bulkDeleteMessages(channel, messages) {\n    return this.rest.makeRequest('post', Endpoints.Channel(channel).messages.bulkDelete, true, {\n      messages: messages\n    }).then(() => this.client.actions.MessageDeleteBulk.handle({\n      channel_id: channel.id,\n      ids: messages\n    }).messages);\n  }\n\n  search(target, options) {\n    if (typeof options === 'string') options = {\n      content: options\n    };\n\n    if (options.before) {\n      if (!(options.before instanceof Date)) options.before = new Date(options.before);\n      options.maxID = long.fromNumber(options.before.getTime() - 14200704e5).shiftLeft(22).toString();\n    }\n\n    if (options.after) {\n      if (!(options.after instanceof Date)) options.after = new Date(options.after);\n      options.minID = long.fromNumber(options.after.getTime() - 14200704e5).shiftLeft(22).toString();\n    }\n\n    if (options.during) {\n      if (!(options.during instanceof Date)) options.during = new Date(options.during);\n      const t = options.during.getTime() - 14200704e5;\n      options.minID = long.fromNumber(t).shiftLeft(22).toString();\n      options.maxID = long.fromNumber(t + 86400000).shiftLeft(22).toString();\n    }\n\n    if (options.channel) options.channel = this.client.resolver.resolveChannelID(options.channel);\n    if (options.author) options.author = this.client.resolver.resolveUserID(options.author);\n    if (options.mentions) options.mentions = this.client.resolver.resolveUserID(options.options.mentions);\n    options = {\n      content: options.content,\n      max_id: options.maxID,\n      min_id: options.minID,\n      has: options.has,\n      channel_id: options.channel,\n      author_id: options.author,\n      author_type: options.authorType,\n      context_size: options.contextSize,\n      sort_by: options.sortBy,\n      sort_order: options.sortOrder,\n      limit: options.limit,\n      offset: options.offset,\n      mentions: options.mentions,\n      mentions_everyone: options.mentionsEveryone,\n      link_hostname: options.linkHostname,\n      embed_provider: options.embedProvider,\n      embed_type: options.embedType,\n      attachment_filename: options.attachmentFilename,\n      attachment_extension: options.attachmentExtension,\n      include_nsfw: options.nsfw\n    };\n\n    for (const key in options) if (options[key] === undefined) delete options[key];\n\n    const queryString = (querystring.stringify(options).match(/[^=&?]+=[^=&?]+/g) || []).join('&');\n    let endpoint;\n\n    if (target instanceof Channel) {\n      endpoint = Endpoints.Channel(target).search;\n    } else if (target instanceof Guild) {\n      endpoint = Endpoints.Guild(target).search;\n    } else {\n      throw new TypeError('Target must be a TextChannel, DMChannel, GroupDMChannel, or Guild.');\n    }\n\n    return this.rest.makeRequest('get', \"\".concat(endpoint, \"?\").concat(queryString), true).then(body => {\n      const messages = body.messages.map(x => x.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client)));\n      return {\n        totalResults: body.total_results,\n        messages\n      };\n    });\n  }\n\n  createChannel(guild, name, options) {\n    const type = options.type,\n          topic = options.topic,\n          nsfw = options.nsfw,\n          bitrate = options.bitrate,\n          userLimit = options.userLimit,\n          parent = options.parent,\n          permissionOverwrites = options.permissionOverwrites,\n          position = options.position,\n          rateLimitPerUser = options.rateLimitPerUser,\n          reason = options.reason;\n    return this.rest.makeRequest('post', Endpoints.Guild(guild).channels, true, {\n      name,\n      topic,\n      type: type ? Constants.ChannelTypes[type.toUpperCase()] : 'text',\n      nsfw,\n      bitrate,\n      user_limit: userLimit,\n      parent_id: parent instanceof Channel ? parent.id : parent,\n      permission_overwrites: resolvePermissions.call(this, permissionOverwrites, guild),\n      position,\n      rate_limit_per_user: rateLimitPerUser\n    }, undefined, reason).then(data => this.client.actions.ChannelCreate.handle(data).channel);\n  }\n\n  createDM(recipient) {\n    const dmChannel = this.getExistingDM(recipient);\n    if (dmChannel) return Promise.resolve(dmChannel);\n    return this.rest.makeRequest('post', Endpoints.User(this.client.user).channels, true, {\n      recipient_id: recipient.id\n    }).then(data => this.client.actions.ChannelCreate.handle(data).channel);\n  }\n\n  createGroupDM(options) {\n    const data = this.client.user.bot ? {\n      access_tokens: options.accessTokens,\n      nicks: options.nicks\n    } : {\n      recipients: options.recipients\n    };\n    return this.rest.makeRequest('post', Endpoints.User('@me').channels, true, data).then(res => new GroupDMChannel(this.client, res));\n  }\n\n  addUserToGroupDM(channel, options) {\n    const data = this.client.user.bot ? {\n      nick: options.nick,\n      access_token: options.accessToken\n    } : {\n      recipient: options.id\n    };\n    return this.rest.makeRequest('put', Endpoints.Channel(channel).Recipient(options.id), true, data).then(() => channel);\n  }\n\n  removeUserFromGroupDM(channel, userId) {\n    return this.rest.makeRequest('delete', Endpoints.Channel(channel).Recipient(userId), true).then(() => channel);\n  }\n\n  updateGroupDMChannel(channel, _data) {\n    const data = {};\n    data.name = _data.name;\n    data.icon = _data.icon;\n    return this.rest.makeRequest('patch', Endpoints.Channel(channel), true, data).then(() => channel);\n  }\n\n  getExistingDM(recipient) {\n    return this.client.channels.find(channel => channel.recipient && channel.recipient.id === recipient.id);\n  }\n\n  deleteChannel(channel, reason) {\n    if (channel instanceof User || channel instanceof GuildMember) channel = this.getExistingDM(channel);\n    if (!channel) return Promise.reject(new Error('No channel to delete.'));\n    return this.rest.makeRequest('delete', Endpoints.Channel(channel), true, undefined, undefined, reason).then(data => {\n      data.id = channel.id;\n      return this.client.actions.ChannelDelete.handle(data).channel;\n    });\n  }\n\n  updateChannel(channel, _data, reason) {\n    const data = {};\n    data.name = (_data.name || channel.name).trim();\n    data.topic = typeof _data.topic === 'undefined' ? channel.topic : _data.topic;\n    data.nsfw = typeof _data.nsfw === 'undefined' ? channel.nsfw : _data.nsfw;\n    data.position = _data.position || channel.position;\n    data.bitrate = _data.bitrate || (channel.bitrate ? channel.bitrate * 1000 : undefined);\n    data.user_limit = typeof _data.userLimit !== 'undefined' ? _data.userLimit : channel.userLimit;\n    data.parent_id = _data.parent instanceof Channel ? _data.parent.id : _data.parent;\n    data.permission_overwrites = _data.permissionOverwrites ? resolvePermissions.call(this, _data.permissionOverwrites, channel.guild) : undefined;\n    data.rate_limit_per_user = typeof _data.rateLimitPerUser !== 'undefined' ? _data.rateLimitPerUser : channel.rateLimitPerUser;\n    return this.rest.makeRequest('patch', Endpoints.Channel(channel), true, data, undefined, reason).then(newData => this.client.actions.ChannelUpdate.handle(newData).updated);\n  }\n\n  leaveGuild(guild) {\n    if (guild.ownerID === this.client.user.id) return Promise.reject(new Error('Guild is owned by the client.'));\n    return this.rest.makeRequest('delete', Endpoints.User('@me').Guild(guild.id), true).then(() => this.client.actions.GuildDelete.handle({\n      id: guild.id\n    }).guild);\n  }\n\n  createGuild(options) {\n    options.icon = this.client.resolver.resolveBase64(options.icon) || null;\n    options.region = options.region || 'us-central';\n    return new Promise((resolve, reject) => {\n      this.rest.makeRequest('post', Endpoints.guilds, true, options).then(data => {\n        if (this.client.guilds.has(data.id)) return resolve(this.client.guilds.get(data.id));\n\n        const handleGuild = guild => {\n          if (guild.id === data.id) {\n            this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);\n            this.client.clearTimeout(timeout);\n            resolve(guild);\n          }\n        };\n\n        this.client.on(Constants.Events.GUILD_CREATE, handleGuild);\n        const timeout = this.client.setTimeout(() => {\n          this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);\n          reject(new Error('Took too long to receive guild data.'));\n        }, 10000);\n        return undefined;\n      }, reject);\n    });\n  } // Untested but probably will work\n\n\n  deleteGuild(guild) {\n    return this.rest.makeRequest('delete', Endpoints.Guild(guild), true).then(() => this.client.actions.GuildDelete.handle({\n      id: guild.id\n    }).guild);\n  }\n\n  getUser(userID, cache) {\n    return this.rest.makeRequest('get', Endpoints.User(userID), true).then(data => {\n      if (cache) return this.client.actions.UserGet.handle(data).user;else return new User(this.client, data);\n    });\n  }\n\n  updateCurrentUser(_data, password) {\n    const user = this.client.user;\n    const data = {};\n    data.username = _data.username || user.username;\n    data.avatar = typeof _data.avatar === 'undefined' ? user.avatar : this.client.resolver.resolveBase64(_data.avatar);\n\n    if (!user.bot) {\n      data.email = _data.email || user.email;\n      data.password = password;\n      if (_data.new_password) data.new_password = _data.newPassword;\n    }\n\n    return this.rest.makeRequest('patch', Endpoints.User('@me'), true, data).then(newData => this.client.actions.UserUpdate.handle(newData).updated);\n  }\n\n  updateGuild(guild, data, reason) {\n    return this.rest.makeRequest('patch', Endpoints.Guild(guild), true, data, undefined, reason).then(newData => this.client.actions.GuildUpdate.handle(newData).updated);\n  }\n\n  kickGuildMember(guild, member, reason) {\n    return this.rest.makeRequest('delete', Endpoints.Guild(guild).Member(member), true, undefined, undefined, reason).then(() => member);\n  }\n\n  createGuildRole(guild, data, reason) {\n    if (data.color) data.color = this.client.resolver.resolveColor(data.color);\n    if (data.permissions) data.permissions = Permissions.resolve(data.permissions);\n    return this.rest.makeRequest('post', Endpoints.Guild(guild).roles, true, data, undefined, reason).then(r => {\n      const _this$client$actions$ = this.client.actions.GuildRoleCreate.handle({\n        guild_id: guild.id,\n        role: r\n      }),\n            role = _this$client$actions$.role;\n\n      if (data.position) return role.setPosition(data.position, reason);\n      return role;\n    });\n  }\n\n  deleteGuildRole(role, reason) {\n    return this.rest.makeRequest('delete', Endpoints.Guild(role.guild).Role(role.id), true, undefined, undefined, reason).then(() => this.client.actions.GuildRoleDelete.handle({\n      guild_id: role.guild.id,\n      role_id: role.id\n    }).role);\n  }\n\n  setChannelOverwrite(channel, payload) {\n    return this.rest.makeRequest('put', \"\".concat(Endpoints.Channel(channel).permissions, \"/\").concat(payload.id), true, payload);\n  }\n\n  deletePermissionOverwrites(overwrite, reason) {\n    return this.rest.makeRequest('delete', \"\".concat(Endpoints.Channel(overwrite.channel).permissions, \"/\").concat(overwrite.id), true, undefined, undefined, reason).then(() => overwrite);\n  }\n\n  getChannelMessages(channel, payload = {}) {\n    const params = [];\n    if (payload.limit) params.push(\"limit=\".concat(payload.limit));\n    if (payload.around) params.push(\"around=\".concat(payload.around));else if (payload.before) params.push(\"before=\".concat(payload.before));else if (payload.after) params.push(\"after=\".concat(payload.after));\n    let endpoint = Endpoints.Channel(channel).messages;\n    if (params.length > 0) endpoint += \"?\".concat(params.join('&'));\n    return this.rest.makeRequest('get', endpoint, true);\n  }\n\n  getChannelMessage(channel, messageID) {\n    const msg = channel.messages.get(messageID);\n    if (msg) return Promise.resolve(msg);\n    return this.rest.makeRequest('get', Endpoints.Channel(channel).Message(messageID), true);\n  }\n\n  putGuildMember(guild, userID, options) {\n    options.access_token = options.accessToken;\n\n    if (options.roles) {\n      const roles = options.roles;\n\n      if (roles instanceof Collection || roles instanceof Array && roles[0] instanceof Role) {\n        options.roles = roles.map(role => role.id);\n      }\n    }\n\n    return this.rest.makeRequest('put', Endpoints.Guild(guild).Member(userID), true, options).then(data => this.client.actions.GuildMemberGet.handle(guild, data).member);\n  }\n\n  getGuildMember(guild, user, cache) {\n    return this.rest.makeRequest('get', Endpoints.Guild(guild).Member(user.id), true).then(data => {\n      if (cache) return this.client.actions.GuildMemberGet.handle(guild, data).member;else return new GuildMember(guild, data);\n    });\n  }\n\n  updateGuildMember(member, data, reason) {\n    if (data.channel) {\n      const channel = this.client.resolver.resolveChannel(data.channel);\n\n      if (!channel || channel.guild.id !== member.guild.id || channel.type !== 'voice') {\n        return Promise.reject(new Error('Could not resolve channel to a guild voice channel.'));\n      }\n\n      data.channel_id = channel.id;\n      data.channel = undefined;\n    } else if (data.channel === null) {\n      data.channel_id = null;\n      data.channel = undefined;\n    }\n\n    if (data.roles) data.roles = data.roles.map(role => role instanceof Role ? role.id : role);\n    let endpoint = Endpoints.Member(member); // Fix your endpoints, discord ;-;\n\n    if (member.id === this.client.user.id) {\n      const keys = Object.keys(data);\n\n      if (keys.length === 1 && keys[0] === 'nick') {\n        endpoint = Endpoints.Member(member).nickname;\n      }\n    }\n\n    return this.rest.makeRequest('patch', endpoint, true, data, undefined, reason).then(newData => member.guild._updateMember(member, newData).mem);\n  }\n\n  addMemberRole(member, role, reason) {\n    return new Promise((resolve, reject) => {\n      if (member._roles.includes(role.id)) return resolve(member);\n\n      const listener = (oldMember, newMember) => {\n        if (newMember.id === member.id && !oldMember._roles.includes(role.id) && newMember._roles.includes(role.id)) {\n          this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n          resolve(newMember);\n        }\n      };\n\n      this.client.on(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n        reject(new Error('Adding the role timed out.'));\n      }, 10e3);\n      return this.rest.makeRequest('put', Endpoints.Member(member).Role(role.id), true, undefined, undefined, reason).catch(err => {\n        this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n        this.client.clearTimeout(timeout);\n        reject(err);\n      });\n    });\n  }\n\n  removeMemberRole(member, role, reason) {\n    return new Promise((resolve, reject) => {\n      if (!member._roles.includes(role.id)) return resolve(member);\n\n      const listener = (oldMember, newMember) => {\n        if (newMember.id === member.id && oldMember._roles.includes(role.id) && !newMember._roles.includes(role.id)) {\n          this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n          resolve(newMember);\n        }\n      };\n\n      this.client.on(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n        reject(new Error('Removing the role timed out.'));\n      }, 10e3);\n      return this.rest.makeRequest('delete', Endpoints.Member(member).Role(role.id), true, undefined, undefined, reason).catch(err => {\n        this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);\n        this.client.clearTimeout(timeout);\n        reject(err);\n      });\n    });\n  }\n\n  sendTyping(channelID) {\n    return this.rest.makeRequest('post', Endpoints.Channel(channelID).typing, true);\n  }\n\n  banGuildMember(guild, member, options) {\n    const id = this.client.resolver.resolveUserID(member);\n    if (!id) return Promise.reject(new Error('Couldn\\'t resolve the user ID to ban.'));\n    const url = \"\".concat(Endpoints.Guild(guild).bans, \"/\").concat(id, \"?\").concat(querystring.stringify(options));\n    return this.rest.makeRequest('put', url, true).then(() => {\n      if (member instanceof GuildMember) return member;\n      const user = this.client.resolver.resolveUser(id);\n\n      if (user) {\n        member = this.client.resolver.resolveGuildMember(guild, user);\n        return member || user;\n      }\n\n      return id;\n    });\n  }\n\n  unbanGuildMember(guild, member, reason) {\n    return new Promise((resolve, reject) => {\n      const id = this.client.resolver.resolveUserID(member);\n      if (!id) throw new Error('Couldn\\'t resolve the user ID to unban.');\n\n      const listener = (eGuild, eUser) => {\n        if (eGuild.id === guild.id && eUser.id === id) {\n          this.client.removeListener(Constants.Events.GUILD_BAN_REMOVE, listener);\n          this.client.clearTimeout(timeout);\n          resolve(eUser);\n        }\n      };\n\n      this.client.on(Constants.Events.GUILD_BAN_REMOVE, listener);\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Constants.Events.GUILD_BAN_REMOVE, listener);\n        reject(new Error('Took too long to receive the ban remove event.'));\n      }, 10000);\n      this.rest.makeRequest('delete', \"\".concat(Endpoints.Guild(guild).bans, \"/\").concat(id), true, undefined, undefined, reason).catch(err => {\n        this.client.removeListener(Constants.Events.GUILD_BAN_REMOVE, listener);\n        this.client.clearTimeout(timeout);\n        reject(err);\n      });\n    });\n  }\n\n  getGuildBan(guild, user) {\n    const id = this.client.resolver.resolveUserID(user);\n    return this.rest.makeRequest('get', \"\".concat(Endpoints.Guild(guild).bans, \"/\").concat(id), true).then(ban => ({\n      reason: ban.reason,\n      user: this.client.dataManager.newUser(ban.user)\n    }));\n  }\n\n  getGuildBans(guild) {\n    return this.rest.makeRequest('get', Endpoints.Guild(guild).bans, true).then(bans => bans.reduce((collection, ban) => {\n      collection.set(ban.user.id, {\n        reason: ban.reason,\n        user: this.client.dataManager.newUser(ban.user)\n      });\n      return collection;\n    }, new Collection()));\n  }\n\n  updateGuildRole(role, _data, reason) {\n    const data = {};\n    data.name = _data.name || role.name;\n    data.position = typeof _data.position !== 'undefined' ? _data.position : role.position;\n    data.color = _data.color === null ? null : this.client.resolver.resolveColor(_data.color || role.color);\n    data.hoist = typeof _data.hoist !== 'undefined' ? _data.hoist : role.hoist;\n    data.mentionable = typeof _data.mentionable !== 'undefined' ? _data.mentionable : role.mentionable;\n    if (typeof _data.permissions !== 'undefined') data.permissions = Permissions.resolve(_data.permissions);else data.permissions = role.permissions;\n    return this.rest.makeRequest('patch', Endpoints.Guild(role.guild).Role(role.id), true, data, undefined, reason).then(_role => this.client.actions.GuildRoleUpdate.handle({\n      role: _role,\n      guild_id: role.guild.id\n    }).updated);\n  }\n\n  pinMessage(message) {\n    return this.rest.makeRequest('put', Endpoints.Channel(message.channel).Pin(message.id), true).then(() => message);\n  }\n\n  unpinMessage(message) {\n    return this.rest.makeRequest('delete', Endpoints.Channel(message.channel).Pin(message.id), true).then(() => message);\n  }\n\n  getChannelPinnedMessages(channel) {\n    return this.rest.makeRequest('get', Endpoints.Channel(channel).pins, true);\n  }\n\n  createChannelInvite(channel, options, reason) {\n    const payload = {};\n    payload.temporary = options.temporary;\n    payload.max_age = options.maxAge;\n    payload.max_uses = options.maxUses;\n    payload.unique = options.unique;\n    return this.rest.makeRequest('post', Endpoints.Channel(channel).invites, true, payload, undefined, reason).then(invite => new Invite(this.client, invite));\n  }\n\n  deleteInvite(invite, reason) {\n    return this.rest.makeRequest('delete', Endpoints.Invite(invite.code), true, undefined, undefined, reason).then(() => invite);\n  }\n\n  getInvite(code) {\n    return this.rest.makeRequest('get', Endpoints.Invite(code), true).then(invite => new Invite(this.client, invite));\n  }\n\n  getGuildInvites(guild) {\n    return this.rest.makeRequest('get', Endpoints.Guild(guild).invites, true).then(inviteItems => {\n      const invites = new Collection();\n\n      for (const inviteItem of inviteItems) {\n        const invite = new Invite(this.client, inviteItem);\n        invites.set(invite.code, invite);\n      }\n\n      return invites;\n    });\n  }\n\n  getGuildVanityCode(guild) {\n    return this.rest.makeRequest('get', Endpoints.Guild(guild).vanityURL, true).then(res => res.code);\n  }\n\n  pruneGuildMembers(guild, days, dry, reason) {\n    return this.rest.makeRequest(dry ? 'get' : 'post', \"\".concat(Endpoints.Guild(guild).prune, \"?days=\").concat(days), true, undefined, undefined, reason).then(data => data.pruned);\n  }\n\n  createEmoji(guild, image, name, roles, reason) {\n    const data = {\n      image,\n      name\n    };\n    if (roles) data.roles = roles.map(r => r.id ? r.id : r);\n    return this.rest.makeRequest('post', Endpoints.Guild(guild).emojis, true, data, undefined, reason).then(emoji => this.client.actions.GuildEmojiCreate.handle(guild, emoji).emoji);\n  }\n\n  updateEmoji(emoji, _data, reason) {\n    const data = {};\n    if (_data.name) data.name = _data.name;\n    if (_data.roles) data.roles = _data.roles.map(r => r.id ? r.id : r);\n    return this.rest.makeRequest('patch', Endpoints.Guild(emoji.guild).Emoji(emoji.id), true, data, undefined, reason).then(newEmoji => this.client.actions.GuildEmojiUpdate.handle(emoji, newEmoji).emoji);\n  }\n\n  deleteEmoji(emoji, reason) {\n    return this.rest.makeRequest('delete', Endpoints.Guild(emoji.guild).Emoji(emoji.id), true, undefined, reason).then(() => this.client.actions.GuildEmojiDelete.handle(emoji).data);\n  }\n\n  getGuildAuditLogs(guild, options = {}) {\n    if (options.before && options.before instanceof GuildAuditLogs.Entry) options.before = options.before.id;\n    if (options.after && options.after instanceof GuildAuditLogs.Entry) options.after = options.after.id;\n    if (typeof options.type === 'string') options.type = GuildAuditLogs.Actions[options.type];\n    const queryString = (querystring.stringify({\n      before: options.before,\n      after: options.after,\n      limit: options.limit,\n      user_id: this.client.resolver.resolveUserID(options.user),\n      action_type: options.type\n    }).match(/[^=&?]+=[^=&?]+/g) || []).join('&');\n    return this.rest.makeRequest('get', \"\".concat(Endpoints.Guild(guild).auditLogs, \"?\").concat(queryString), true).then(data => GuildAuditLogs.build(guild, data));\n  }\n\n  getWebhook(id, token) {\n    return this.rest.makeRequest('get', Endpoints.Webhook(id, token), !token).then(data => new Webhook(this.client, data));\n  }\n\n  getGuildWebhooks(guild) {\n    return this.rest.makeRequest('get', Endpoints.Guild(guild).webhooks, true).then(data => {\n      const hooks = new Collection();\n\n      for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));\n\n      return hooks;\n    });\n  }\n\n  getChannelWebhooks(channel) {\n    return this.rest.makeRequest('get', Endpoints.Channel(channel).webhooks, true).then(data => {\n      const hooks = new Collection();\n\n      for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));\n\n      return hooks;\n    });\n  }\n\n  createWebhook(channel, name, avatar, reason) {\n    return this.rest.makeRequest('post', Endpoints.Channel(channel).webhooks, true, {\n      name,\n      avatar\n    }, undefined, reason).then(data => new Webhook(this.client, data));\n  }\n\n  editWebhook(webhook, name, avatar) {\n    return this.rest.makeRequest('patch', Endpoints.Webhook(webhook.id, webhook.token), false, {\n      name,\n      avatar\n    }).then(data => {\n      webhook.name = data.name;\n      webhook.avatar = data.avatar;\n      return webhook;\n    });\n  }\n\n  deleteWebhook(webhook, reason) {\n    return this.rest.makeRequest('delete', Endpoints.Webhook(webhook.id, webhook.token), false, undefined, undefined, reason);\n  }\n\n  sendWebhookMessage(webhook, content, {\n    avatarURL,\n    tts,\n    embeds,\n    username\n  } = {}, files = null) {\n    return new Promise((resolve, reject) => {\n      username = username || webhook.name;\n\n      if (content instanceof Array) {\n        const messages = [];\n\n        (function sendChunk(list, index) {\n          const options = index === list.length - 1 ? {\n            tts,\n            embeds,\n            files\n          } : {\n            tts\n          };\n          webhook.send(list[index], options).then(message => {\n            messages.push(message);\n            if (index >= list.length - 1) return resolve(messages);\n            return sendChunk(list, ++index);\n          }).catch(reject);\n        })(content, 0);\n      } else {\n        this.rest.makeRequest('post', \"\".concat(Endpoints.Webhook(webhook.id, webhook.token), \"?wait=true\"), false, {\n          username,\n          avatar_url: avatarURL,\n          content,\n          tts,\n          embeds\n        }, files).then(data => {\n          if (!this.client.channels) resolve(data);else resolve(this.client.actions.MessageCreate.handle(data).message);\n        }, reject);\n      }\n    });\n  }\n\n  sendSlackWebhookMessage(webhook, body) {\n    return this.rest.makeRequest('post', \"\".concat(Endpoints.Webhook(webhook.id, webhook.token), \"/slack?wait=true\"), false, body);\n  }\n\n  fetchUserProfile(user) {\n    return this.rest.makeRequest('get', Endpoints.User(user).profile, true).then(data => new UserProfile(user, data));\n  }\n\n  fetchMentions(options) {\n    if (options.guild instanceof Guild) options.guild = options.guild.id;\n    Util.mergeDefault({\n      limit: 25,\n      roles: true,\n      everyone: true,\n      guild: null\n    }, options);\n    return this.rest.makeRequest('get', Endpoints.User('@me').Mentions(options.limit, options.roles, options.everyone, options.guild), true).then(data => data.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client)));\n  }\n\n  addFriend(user) {\n    return this.rest.makeRequest('post', Endpoints.User('@me'), true, {\n      username: user.username,\n      discriminator: user.discriminator\n    }).then(() => user);\n  }\n\n  removeFriend(user) {\n    return this.rest.makeRequest('delete', Endpoints.User('@me').Relationship(user.id), true).then(() => user);\n  }\n\n  blockUser(user) {\n    return this.rest.makeRequest('put', Endpoints.User('@me').Relationship(user.id), true, {\n      type: 2\n    }).then(() => user);\n  }\n\n  unblockUser(user) {\n    return this.rest.makeRequest('delete', Endpoints.User('@me').Relationship(user.id), true).then(() => user);\n  }\n\n  updateChannelPositions(guildID, channels) {\n    const data = new Array(channels.length);\n\n    for (let i = 0; i < channels.length; i++) {\n      data[i] = {\n        id: this.client.resolver.resolveChannelID(channels[i].channel),\n        position: channels[i].position\n      };\n    }\n\n    return this.rest.makeRequest('patch', Endpoints.Guild(guildID).channels, true, data).then(() => this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: guildID,\n      channels\n    }).guild);\n  }\n\n  updateEmbed(guildID, embed, reason) {\n    return this.rest.makeRequest('patch', Endpoints.Guild(guildID).embed, true, {\n      enabled: embed.enabled,\n      channel_id: this.client.resolver.resolveChannelID(embed.channel)\n    }, undefined, reason);\n  }\n\n  setRolePositions(guildID, roles) {\n    return this.rest.makeRequest('patch', Endpoints.Guild(guildID).roles, true, roles).then(() => this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: guildID,\n      roles\n    }).guild);\n  }\n\n  setChannelPositions(guildID, channels) {\n    return this.rest.makeRequest('patch', Endpoints.Guild(guildID).channels, true, channels).then(() => this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: guildID,\n      channels\n    }).guild);\n  }\n\n  addMessageReaction(message, emoji) {\n    return this.rest.makeRequest('put', Endpoints.Message(message).Reaction(emoji).User('@me'), true).then(() => message._addReaction(Util.parseEmoji(emoji), message.client.user));\n  }\n\n  removeMessageReaction(message, emoji, userID) {\n    const endpoint = Endpoints.Message(message).Reaction(emoji).User(userID === this.client.user.id ? '@me' : userID);\n    return this.rest.makeRequest('delete', endpoint, true).then(() => this.client.actions.MessageReactionRemove.handle({\n      user_id: userID,\n      message_id: message.id,\n      emoji: Util.parseEmoji(emoji),\n      channel_id: message.channel.id\n    }).reaction);\n  }\n\n  removeMessageReactions(message) {\n    return this.rest.makeRequest('delete', Endpoints.Message(message).reactions, true).then(() => message);\n  }\n\n  getMessageReactionUsers(message, emoji, options) {\n    const queryString = (querystring.stringify(options).match(/[^=&?]+=[^=&?]+/g) || []).join('&');\n    return this.rest.makeRequest('get', \"\".concat(Endpoints.Message(message).Reaction(emoji), \"?\").concat(queryString), true);\n  }\n\n  getApplication(id) {\n    return this.rest.makeRequest('get', Endpoints.OAUTH2.Application(id), true).then(app => new OAuth2Application(this.client, app));\n  }\n\n  resetApplication(id) {\n    return this.rest.makeRequest('post', Endpoints.OAUTH2.Application(id).resetToken, true).then(() => this.rest.makeRequest('post', Endpoints.OAUTH2.Application(id).resetSecret, true)).then(app => new OAuth2Application(this.client, app));\n  }\n\n  setNote(user, note) {\n    return this.rest.makeRequest('put', Endpoints.User(user).note, true, {\n      note\n    }).then(() => user);\n  }\n\n  acceptInvite(code) {\n    if (code.id) code = code.id;\n    return new Promise((resolve, reject) => this.rest.makeRequest('post', Endpoints.Invite(code), true).then(res => {\n      const handler = guild => {\n        if (guild.id === res.id) {\n          resolve(guild);\n          this.client.removeListener(Constants.Events.GUILD_CREATE, handler);\n        }\n      };\n\n      this.client.on(Constants.Events.GUILD_CREATE, handler);\n      this.client.setTimeout(() => {\n        this.client.removeListener(Constants.Events.GUILD_CREATE, handler);\n        reject(new Error('Accepting invite timed out'));\n      }, 120e3);\n    }));\n  }\n\n  patchUserSettings(data) {\n    return this.rest.makeRequest('patch', Constants.Endpoints.User('@me').settings, true, data);\n  }\n\n  patchClientUserGuildSettings(guildID, data) {\n    return this.rest.makeRequest('patch', Constants.Endpoints.User('@me').Guild(guildID).settings, true, data);\n  }\n\n}\n\nmodule.exports = RESTMethods;","map":null,"metadata":{},"sourceType":"script"}