{"ast":null,"code":"const EventEmitter = require('events');\n\nconst Constants = require('../util/Constants');\n\nconst Permissions = require('../util/Permissions');\n\nconst Util = require('../util/Util');\n\nconst RESTManager = require('./rest/RESTManager');\n\nconst ClientDataManager = require('./ClientDataManager');\n\nconst ClientManager = require('./ClientManager');\n\nconst ClientDataResolver = require('./ClientDataResolver');\n\nconst ClientVoiceManager = require('./voice/ClientVoiceManager');\n\nconst WebSocketManager = require('./websocket/WebSocketManager');\n\nconst ActionsManager = require('./actions/ActionsManager');\n\nconst Collection = require('../util/Collection');\n\nconst Presence = require('../structures/Presence').Presence;\n\nconst ShardClientUtil = require('../sharding/ShardClientUtil');\n\nconst VoiceBroadcast = require('./voice/VoiceBroadcast');\n/**\n * The main hub for interacting with the Discord API, and the starting point for any bot.\n * @extends {EventEmitter}\n */\n\n\nclass Client extends EventEmitter {\n  /**\n   * @param {ClientOptions} [options] Options for the client\n   */\n  constructor(options = {}) {\n    super(); // Obtain shard details from environment\n\n    if (!options.shardId && 'SHARD_ID' in process.env) options.shardId = Number(process.env.SHARD_ID);\n    if (!options.shardCount && 'SHARD_COUNT' in process.env) options.shardCount = Number(process.env.SHARD_COUNT);\n    /**\n     * The options the client was instantiated with\n     * @type {ClientOptions}\n     */\n\n    this.options = Util.mergeDefault(Constants.DefaultOptions, options);\n\n    this._validateOptions();\n    /**\n     * The REST manager of the client\n     * @type {RESTManager}\n     * @private\n     */\n\n\n    this.rest = new RESTManager(this);\n    /**\n     * The data manager of the client\n     * @type {ClientDataManager}\n     * @private\n     */\n\n    this.dataManager = new ClientDataManager(this);\n    /**\n     * The manager of the client\n     * @type {ClientManager}\n     * @private\n     */\n\n    this.manager = new ClientManager(this);\n    /**\n     * The WebSocket manager of the client\n     * @type {WebSocketManager}\n     * @private\n     */\n\n    this.ws = new WebSocketManager(this);\n    /**\n     * The data resolver of the client\n     * @type {ClientDataResolver}\n     * @private\n     */\n\n    this.resolver = new ClientDataResolver(this);\n    /**\n     * The action manager of the client\n     * @type {ActionsManager}\n     * @private\n     */\n\n    this.actions = new ActionsManager(this);\n    /**\n     * The voice manager of the client (`null` in browsers)\n     * @type {?ClientVoiceManager}\n     * @private\n     */\n\n    this.voice = !this.browser ? new ClientVoiceManager(this) : null;\n    /**\n     * The shard helpers for the client\n     * (only if the process was spawned as a child, such as from a {@link ShardingManager})\n     * @type {?ShardClientUtil}\n     */\n\n    this.shard = process.send ? ShardClientUtil.singleton(this) : null;\n    /**\n     * All of the {@link User} objects that have been cached at any point, mapped by their IDs\n     * @type {Collection<Snowflake, User>}\n     */\n\n    this.users = new Collection();\n    /**\n     * All of the guilds the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* guild the bot is a member of\n     * @type {Collection<Snowflake, Guild>}\n     */\n\n    this.guilds = new Collection();\n    /**\n     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* channel in *every* guild, and all DM channels\n     * @type {Collection<Snowflake, Channel>}\n     */\n\n    this.channels = new Collection();\n    /**\n     * Presences that have been received for the client user's friends, mapped by user IDs\n     * <warn>This is only filled when using a user account.</warn>\n     * @type {Collection<Snowflake, Presence>}\n     * @deprecated\n     */\n\n    this.presences = new Collection();\n    Object.defineProperty(this, 'token', {\n      writable: true\n    });\n\n    if (!this.token && 'CLIENT_TOKEN' in process.env) {\n      /**\n       * Authorization token for the logged in user/bot\n       * <warn>This should be kept private at all times.</warn>\n       * @type {?string}\n       */\n      this.token = process.env.CLIENT_TOKEN;\n    } else {\n      this.token = null;\n    }\n    /**\n     * User that the client is logged in as\n     * @type {?ClientUser}\n     */\n\n\n    this.user = null;\n    /**\n     * Time at which the client was last regarded as being in the `READY` state\n     * (each time the client disconnects and successfully reconnects, this will be overwritten)\n     * @type {?Date}\n     */\n\n    this.readyAt = null;\n    /**\n     * Active voice broadcasts that have been created\n     * @type {VoiceBroadcast[]}\n     */\n\n    this.broadcasts = [];\n    /**\n     * Previous heartbeat pings of the websocket (most recent first, limited to three elements)\n     * @type {number[]}\n     */\n\n    this.pings = [];\n    /**\n     * Timeouts set by {@link Client#setTimeout} that are still active\n     * @type {Set<Timeout>}\n     * @private\n     */\n\n    this._timeouts = new Set();\n    /**\n     * Intervals set by {@link Client#setInterval} that are still active\n     * @type {Set<Timeout>}\n     * @private\n     */\n\n    this._intervals = new Set();\n\n    if (this.options.messageSweepInterval > 0) {\n      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);\n    }\n  }\n  /**\n   * Timestamp of the latest ping's start time\n   * @type {number}\n   * @private\n   */\n\n\n  get _pingTimestamp() {\n    return this.ws.connection ? this.ws.connection.lastPingTimestamp : 0;\n  }\n  /**\n   * Current status of the client's connection to Discord\n   * @type {Status}\n   * @readonly\n   */\n\n\n  get status() {\n    return this.ws.connection ? this.ws.connection.status : Constants.Status.IDLE;\n  }\n  /**\n   * How long it has been since the client last entered the `READY` state in milliseconds\n   * @type {?number}\n   * @readonly\n   */\n\n\n  get uptime() {\n    return this.readyAt ? Date.now() - this.readyAt : null;\n  }\n  /**\n   * Average heartbeat ping of the websocket, obtained by averaging the {@link Client#pings} property\n   * @type {number}\n   * @readonly\n   */\n\n\n  get ping() {\n    return this.pings.reduce((prev, p) => prev + p, 0) / this.pings.length;\n  }\n  /**\n   * All active voice connections that have been established, mapped by guild ID\n   * @type {Collection<Snowflake, VoiceConnection>}\n   * @readonly\n   */\n\n\n  get voiceConnections() {\n    if (this.browser) return new Collection();\n    return this.voice.connections;\n  }\n  /**\n   * All custom emojis that the client has access to, mapped by their IDs\n   * @type {Collection<Snowflake, Emoji>}\n   * @readonly\n   */\n\n\n  get emojis() {\n    const emojis = new Collection();\n\n    for (const guild of this.guilds.values()) {\n      for (const emoji of guild.emojis.values()) emojis.set(emoji.id, emoji);\n    }\n\n    return emojis;\n  }\n  /**\n   * Timestamp of the time the client was last `READY` at\n   * @type {?number}\n   * @readonly\n   */\n\n\n  get readyTimestamp() {\n    return this.readyAt ? this.readyAt.getTime() : null;\n  }\n  /**\n   * Whether the client is in a browser environment\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get browser() {\n    return typeof window !== 'undefined';\n  }\n  /**\n   * Creates a voice broadcast.\n   * @returns {VoiceBroadcast}\n   */\n\n\n  createVoiceBroadcast() {\n    const broadcast = new VoiceBroadcast(this);\n    this.broadcasts.push(broadcast);\n    return broadcast;\n  }\n  /**\n   * Logs the client in, establishing a websocket connection to Discord.\n   * <info>Both bot and regular user accounts are supported, but it is highly recommended to use a bot account whenever\n   * possible. User accounts are subject to harsher ratelimits and other restrictions that don't apply to bot accounts.\n   * Bot accounts also have access to many features that user accounts cannot utilise. Automating a user account is\n   * considered a violation of the ToS.</info>\n   * @param {string} token Token of the account to log in with\n   * @returns {Promise<string>} Token of the account used\n   * @example\n   * client.login('my token')\n   *  .then(console.log)\n   *  .catch(console.error);\n   */\n\n\n  login(token = this.token) {\n    return this.rest.methods.login(token);\n  }\n  /**\n   * Logs out, terminates the connection to Discord, and destroys the client.\n   * @returns {Promise}\n   */\n\n\n  destroy() {\n    for (const t of this._timeouts) clearTimeout(t);\n\n    for (const i of this._intervals) clearInterval(i);\n\n    this._timeouts.clear();\n\n    this._intervals.clear();\n\n    return this.manager.destroy();\n  }\n  /**\n   * Requests a sync of guild data with Discord.\n   * <info>This can be done automatically every 30 seconds by enabling {@link ClientOptions#sync}.</info>\n   * <warn>This is only available when using a user account.</warn>\n   * @param {Guild[]|Collection<Snowflake, Guild>} [guilds=this.guilds] An array or collection of guilds to sync\n   * @deprecated\n   */\n\n\n  syncGuilds(guilds = this.guilds) {\n    if (this.user.bot) return;\n    this.ws.send({\n      op: 12,\n      d: guilds instanceof Collection ? guilds.keyArray() : guilds.map(g => g.id)\n    });\n  }\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * <warn>This is only available when using a bot account.</warn>\n   * @param {Snowflake} id ID of the user\n   * @param {boolean} [cache=true] Whether to cache the new user object if it isn't already\n   * @returns {Promise<User>}\n   */\n\n\n  fetchUser(id, cache = true) {\n    if (this.users.has(id)) return Promise.resolve(this.users.get(id));\n    return this.rest.methods.getUser(id, cache);\n  }\n  /**\n   * Obtains an invite from Discord.\n   * @param {InviteResolvable} invite Invite code or URL\n   * @returns {Promise<Invite>}\n   * @example\n   * client.fetchInvite('https://discord.gg/bRCvFy9')\n   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchInvite(invite) {\n    const code = this.resolver.resolveInviteCode(invite);\n    return this.rest.methods.getInvite(code);\n  }\n  /**\n   * Obtains a webhook from Discord.\n   * @param {Snowflake} id ID of the webhook\n   * @param {string} [token] Token for the webhook\n   * @returns {Promise<Webhook>}\n   * @example\n   * client.fetchWebhook('id', 'token')\n   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchWebhook(id, token) {\n    return this.rest.methods.getWebhook(id, token);\n  }\n  /**\n   * Obtains the available voice regions from Discord.\n   * @returns {Collection<string, VoiceRegion>}\n   * @example\n   * client.fetchVoiceRegions()\n   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchVoiceRegions() {\n    return this.rest.methods.fetchVoiceRegions();\n  }\n  /**\n   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.\n   * If the message has been edited, the time of the edit is used rather than the time of the original message.\n   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)\n   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}\n   * @returns {number} Amount of messages that were removed from the caches,\n   * or -1 if the message cache lifetime is unlimited\n   */\n\n\n  sweepMessages(lifetime = this.options.messageCacheLifetime) {\n    if (typeof lifetime !== 'number' || isNaN(lifetime)) throw new TypeError('The lifetime must be a number.');\n\n    if (lifetime <= 0) {\n      this.emit('debug', 'Didn\\'t sweep messages - lifetime is unlimited');\n      return -1;\n    }\n\n    const lifetimeMs = lifetime * 1000;\n    const now = Date.now();\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.channels.values()) {\n      if (!channel.messages) continue;\n      channels++;\n      messages += channel.messages.sweep(message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs);\n    }\n\n    this.emit('debug', \"Swept \".concat(messages, \" messages older than \").concat(lifetime, \" seconds in \").concat(channels, \" text-based channels\"));\n    return messages;\n  }\n  /**\n   * Obtains the OAuth Application of the bot from Discord.\n   * <warn>Bots can only fetch their own profile.</warn>\n   * @param {Snowflake} [id='@me'] ID of application to fetch\n   * @returns {Promise<OAuth2Application>}\n   * @example\n   * client.fetchApplication()\n   *   .then(application => console.log(`Obtained application with name: ${application.name}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchApplication(id = '@me') {\n    if (id !== '@me') process.emitWarning('fetchApplication: use \"@me\" as an argument', 'DeprecationWarning');\n    return this.rest.methods.getApplication(id);\n  }\n  /**\n   * Generates a link that can be used to invite the bot to a guild.\n   * <warn>This is only available when using a bot account.</warn>\n   * @param {PermissionResolvable} [permissions] Permissions to request\n   * @returns {Promise<string>}\n   * @example\n   * client.generateInvite(['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'])\n   *   .then(link => console.log(`Generated bot invite link: ${link}`))\n   *   .catch(console.error);\n   */\n\n\n  generateInvite(permissions) {\n    permissions = typeof permissions === 'undefined' ? 0 : Permissions.resolve(permissions);\n    return this.fetchApplication().then(application => \"https://discordapp.com/oauth2/authorize?client_id=\".concat(application.id, \"&permissions=\").concat(permissions, \"&scope=bot\"));\n  }\n  /**\n   * Sets a timeout that will be automatically cancelled if the client is destroyed.\n   * @param {Function} fn Function to execute\n   * @param {number} delay Time to wait before executing (in milliseconds)\n   * @param {...*} args Arguments for the function\n   * @returns {Timeout}\n   */\n\n\n  setTimeout(fn, delay, ...args) {\n    const timeout = setTimeout(() => {\n      fn(...args);\n\n      this._timeouts.delete(timeout);\n    }, delay);\n\n    this._timeouts.add(timeout);\n\n    return timeout;\n  }\n  /**\n   * Clears a timeout.\n   * @param {Timeout} timeout Timeout to cancel\n   */\n\n\n  clearTimeout(timeout) {\n    clearTimeout(timeout);\n\n    this._timeouts.delete(timeout);\n  }\n  /**\n   * Sets an interval that will be automatically cancelled if the client is destroyed.\n   * @param {Function} fn Function to execute\n   * @param {number} delay Time to wait before executing (in milliseconds)\n   * @param {...*} args Arguments for the function\n   * @returns {Timeout}\n   */\n\n\n  setInterval(fn, delay, ...args) {\n    const interval = setInterval(fn, delay, ...args);\n\n    this._intervals.add(interval);\n\n    return interval;\n  }\n  /**\n   * Clears an interval.\n   * @param {Timeout} interval Interval to cancel\n   */\n\n\n  clearInterval(interval) {\n    clearInterval(interval);\n\n    this._intervals.delete(interval);\n  }\n  /**\n   * Adds a ping to {@link Client#pings}.\n   * @param {number} startTime Starting time of the ping\n   * @private\n   */\n\n\n  _pong(startTime) {\n    this.pings.unshift(Date.now() - startTime);\n    if (this.pings.length > 3) this.pings.length = 3;\n    this.ws.lastHeartbeatAck = true;\n  }\n  /**\n   * Adds/updates a friend's presence in {@link Client#presences}.\n   * @param {Snowflake} id ID of the user\n   * @param {Object} presence Raw presence object from Discord\n   * @private\n   */\n\n\n  _setPresence(id, presence) {\n    if (this.presences.has(id)) {\n      this.presences.get(id).update(presence);\n      return;\n    }\n\n    this.presences.set(id, new Presence(presence, this));\n  }\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script\n   * with the client as `this`.\n   * @param {string} script Script to eval\n   * @returns {*}\n   * @private\n   */\n\n\n  _eval(script) {\n    return eval(script);\n  }\n  /**\n   * Validates the client options.\n   * @param {ClientOptions} [options=this.options] Options to validate\n   * @private\n   */\n\n\n  _validateOptions(options = this.options) {\n    // eslint-disable-line complexity\n    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount)) {\n      throw new TypeError('The shardCount option must be a number.');\n    }\n\n    if (typeof options.shardId !== 'number' || isNaN(options.shardId)) {\n      throw new TypeError('The shardId option must be a number.');\n    }\n\n    if (options.shardCount < 0) throw new RangeError('The shardCount option must be at least 0.');\n    if (options.shardId < 0) throw new RangeError('The shardId option must be at least 0.');\n\n    if (options.shardId !== 0 && options.shardId >= options.shardCount) {\n      throw new RangeError('The shardId option must be less than shardCount.');\n    }\n\n    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {\n      throw new TypeError('The messageCacheMaxSize option must be a number.');\n    }\n\n    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {\n      throw new TypeError('The messageCacheLifetime option must be a number.');\n    }\n\n    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {\n      throw new TypeError('The messageSweepInterval option must be a number.');\n    }\n\n    if (typeof options.fetchAllMembers !== 'boolean') {\n      throw new TypeError('The fetchAllMembers option must be a boolean.');\n    }\n\n    if (typeof options.disableEveryone !== 'boolean') {\n      throw new TypeError('The disableEveryone option must be a boolean.');\n    }\n\n    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {\n      throw new TypeError('The restWsBridgeTimeout option must be a number.');\n    }\n\n    if (!(options.disabledEvents instanceof Array)) throw new TypeError('The disabledEvents option must be an Array.');\n\n    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {\n      throw new TypeError('The retryLimit  options must be a number.');\n    }\n  }\n\n}\n\nmodule.exports = Client;\n/**\n * Emitted for general warnings.\n * @event Client#warn\n * @param {string} info The warning\n */\n\n/**\n * Emitted for general debugging information.\n * @event Client#debug\n * @param {string} info The debug information\n */","map":null,"metadata":{},"sourceType":"script"}